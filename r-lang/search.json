[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Manuals :: R Language Definition ¶",
    "section": "",
    "text": "Top (R Language Definition)\nNext: Introduction   [Contents][Index]\nR Language Definition ¶\nThis is an introduction to the R language, explaining evaluation, parsing, object oriented programming, computing on the language, and so forth.\nThis manual is for R, version 4.5.0 Under development.\nCopyright © 2000–2024 R Core Team\n\nPermission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.\nPermission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.\nPermission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions, except that this permission notice may be stated in a translation approved by the R Core Team.\n\nNext: Introduction   [Contents][Index]",
    "crumbs": [
      "Top (R Language Definition)"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  Introduction ¶",
    "section": "",
    "text": "Next: Objects, Previous: R Language Definition, Up: R Language Definition   [Contents][Index]\nR is a system for statistical computation and graphics. It provides, among other things, a programming language, high level graphics, interfaces to other languages and debugging facilities. This manual details and defines the R language.\nThe R language is a dialect of S which was designed in the 1980s and has been in widespread use in the statistical community since. Its principal designer, John M. Chambers, was awarded the 1998 ACM Software Systems Award for S.\nThe language syntax has a superficial similarity with C, but the semantics are of the FPL (functional programming language) variety with stronger affinities with Lisp and APL. In particular, it allows “computing on the language”, which in turn makes it possible to write functions that take expressions as input, something that is often useful for statistical modeling and graphics.\nIt is possible to get quite far using R interactively, executing  simple expressions from the command line. Some users may never need to go beyond that level, others will want to write their own functions either in an ad hoc fashion to systematize repetitive work or with the perspective of writing add-on packages for new functionality.\nThe purpose of this manual is to document the language per se. That is, the objects that it works on, and the details of the expression evaluation process, which are useful to know when programming R functions. Major subsystems for specific tasks, such as graphics, are only briefly described in this manual and will be documented separately.\nAlthough much of the text will equally apply to S, there are also some substantial differences, and in order not to confuse the issue we shall concentrate on describing R.\nThe design of the language contains a number of fine points and common pitfalls which may surprise the user. Most of these are due to consistency considerations at a deeper level, as we shall explain. There are also a number of useful shortcuts and idioms, which allow the user to express quite complicated operations succinctly. Many of these become natural once one is familiar with the underlying concepts. In some cases, there are multiple ways of performing a task, but some of the techniques will rely on the language implementation, and others work at a higher level of abstraction. In such cases we shall indicate the preferred usage.\nSome familiarity with R is assumed. This is not an introduction to R but rather a programmers’ reference manual. Other manuals provide complementary information: in particular An Introduction to R provides an introduction to R and System and foreign language interfaces in Writing R Extensions details how to extend R using compiled code.\nNext: Objects, Previous: R Language Definition, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction [¶](#introduction-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Objects.html",
    "href": "Objects.html",
    "title": "2  Objects ¶",
    "section": "",
    "text": "2.1 Basic types ¶\nNext: Evaluation of expressions, Previous: Introduction, Up: R Language Definition   [Contents][Index]\nIn every computer language  variables provide a means of accessing the data stored in memory. R does not provide direct access to the computer’s memory but rather provides a number of specialized data structures we will refer to as  objects. These objects are referred to through symbols or variables. In R, however, the symbols are themselves objects and can be manipulated in the same way as any other object. This is different from many other languages and has wide ranging effects.\nIn this chapter we provide preliminary descriptions of the various data structures provided in R. More detailed discussions of many of them will be found in the subsequent chapters. The R specific function typeof   returns the type of an R object. Note that in the C code underlying R, all objects are pointers to a structure with typedef SEXPREC; the different R data types are represented in C by SEXPTYPE, which determines how the information in the various parts of the structure is used.\nThe following table describes the possible values returned by typeof and what they are.\nUsers cannot easily get hold of objects of types marked with a ‘***’.\nFunction mode gives information about the mode of an object in the sense of Becker, Chambers & Wilks (1988), and is more compatible with other implementations of the S language.  Finally, the function storage.mode returns the storage mode of its argument in the sense of Becker et al. (1988). It is generally used when calling functions written in another language, such as C or FORTRAN, to ensure that R objects have the data type expected by the routine being called. (In the S language, vectors with integer or real values are both of mode \"numeric\", so their storage modes need to be distinguished.)\nR  objects are often coerced to different  types during computations. There are also many functions available to perform explicit  coercion. When programming in the R language the type of an object generally doesn’t affect the computations, however, when dealing with foreign languages or the operating system it is often necessary to ensure that an object is of the correct type.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects [¶](#objects-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Objects.html#basic-types",
    "href": "Objects.html#basic-types",
    "title": "2  Objects ¶",
    "section": "",
    "text": "2.1.1 Vectors ¶\nVectors can be thought of as contiguous cells containing data. Cells are accessed through  indexing operations such as x[5]. More details are given in Indexing.\nR has six basic (‘atomic’) vector types: logical, integer, real, complex, character (in C aka ‘string’) and raw. The modes and storage modes for the different vector types are listed in the following table.\n\n\n\n\ntypeof\nmode\nstorage.mode\n\n\n\n\nlogical\nlogical\nlogical\n\n\ninteger\nnumeric\ninteger\n\n\ndouble\nnumeric\ndouble\n\n\ncomplex\ncomplex\ncomplex\n\n\ncharacter\ncharacter\ncharacter\n\n\nraw\nraw\nraw\n\n\n\n\nSingle numbers, such as 4.2, and strings, such as \"four point two\" are still vectors, of length 1; there are no more basic types. Vectors with length zero are possible (and useful).\nA single element of a character vector is often referred to as a character string or short string. 1\n\n\n2.1.2 Lists ¶\nLists (“generic vectors”) are another kind of data storage. Lists have elements, each of which can contain any type of R object, i.e. the elements of a list do not have to be of the same type. List elements are accessed through three different  indexing operations. These are explained in detail in Indexing.\nLists are vectors, and the basic vector types are referred to as atomic vectors where it is necessary to exclude lists.\n\n\n2.1.3 Language objects ¶\nThere are three types of objects that constitute the R language. They are calls, expressions, and names. \nSince R has objects of type \"expression\" we will try to avoid the use of the word expression in other contexts. In particular syntactically correct expressions will be referred to as statements.\nThese objects have modes \"call\", \"expression\", and \"name\", respectively.\nThey can be created directly from expressions using the quote mechanism and converted to and from lists by the as.list and as.call functions.    Components of the  parse tree can be extracted using the standard indexing operations.\n\n\n2.1.4 Symbol objects ¶\nSymbols refer to R  objects. The  name of any R object is usually a symbol. Symbols can be created through the functions as.name and quote.\nSymbols have mode \"name\", storage mode \"symbol\", and type \"symbol\". They can be  coerced to and from character strings using as.character and as.name.    They naturally appear as atoms of parsed expressions, try e.g. as.list(quote(x + y)).\n\n\n2.1.5 Expression objects ¶\nIn R one can have objects of type \"expression\". An expression contains one or more statements. A statement is a syntactically correct collection of  tokens.  Expression objects are special language objects which contain parsed but unevaluated R statements. The main difference is that an expression object can contain several such expressions. Another more subtle difference is that objects of type \"expression\" are only  evaluated when explicitly passed to eval, whereas other language objects may get evaluated in some unexpected cases.\nAn  expression object behaves much like a list and its components should be accessed in the same way as the components of a list.\n\n\n2.1.6 Function objects ¶\nIn R functions are objects and can be manipulated in much the same way as any other object. Functions (or more precisely, function closures) have three basic components: a formal argument list, a body and an  environment. The argument list is a comma-separated list of arguments. An  argument can be a symbol, or a symbol=default’ construct, or the special argument .... The second form of argument is used to specify a default value for an argument. This value will be used if the function is called without any value specified for that argument. The ... argument is special and can contain any number of arguments. It is generally used if the number of arguments is unknown or in cases where the arguments will be passed on to another function.\nThe body is a parsed R statement. It is usually a collection of statements in braces but it can be a single statement, a symbol or even a constant.\nA function’s   environment is the environment that was active at the time that the function was created. Any symbols bound in that environment are captured and available to the function. This combination of the code of the function and the bindings in its environment is called a ‘function closure’, a term from functional programming theory. In this document we generally use the term ‘function’, but use ‘closure’ to emphasize the importance of the attached environment.\nIt is possible to extract and manipulate the three parts of a closure object using formals, body, and environment constructs (all three can also be used on the left hand side of  assignments).    The last of these can be used to remove unwanted environment capture.\nWhen a function is called, a new environment (called the evaluation environment) is created, whose enclosure (see Environments) is the environment from the function closure. This new environment is initially populated with the unevaluated arguments to the function; as evaluation proceeds, local variables are created within it.\nThere is also a facility for converting functions to and from list structures using as.list and as.function.  These have been included to provide compatibility with S and their use is discouraged.\n\n\n2.1.7 NULL ¶\nThere is a special object called NULL. It is used whenever there is a need to indicate or specify that an object is absent. It should not be confused with a vector or list of zero length.\nThe NULL object has no type and no modifiable properties. There is only one NULL object in R, to which all instances refer. To test for NULL use is.null. You cannot set attributes on NULL.\n\n\n2.1.8 Builtin objects and special forms ¶\nThese two kinds of object contain the builtin    functions of R, i.e., those that are displayed as .Primitive in code listings (as well as those accessed via the .Internal function and hence not user-visible as objects). The difference between the two lies in the argument handling. Builtin functions have all their arguments evaluated and passed to the internal function, in accordance with call-by-value, whereas special functions pass the unevaluated arguments to the internal function.\nFrom the R language, these objects are just another kind of function. The is.primitive function can distinguish them from interpreted  functions.\n\n\n2.1.9 Promise objects ¶\nPromise objects are part of R’s lazy evaluation mechanism. They contain three slots: a value, an expression, and an  environment. When a   function is called the arguments are matched and then each of the formal arguments is bound to a promise. The expression that was given for that formal argument and a pointer to the environment the function was called from are stored in the promise.\nUntil that argument is accessed there is no value associated with the promise. When the argument is accessed, the stored expression is  evaluated in the stored environment, and the result is returned. The result is also saved by the promise. The substitute function will extract the content of the expression slot. This allows the programmer to access either the value or the expression associated with the promise.\nWithin the R language, promise objects are almost only seen implicitly: actual function arguments are of this type. There is also a delayedAssign function that will make a promise out of an expression. There is generally no way in R code to check whether an object is a promise or not, nor is there a way to use R code to determine the environment of a promise.\n\n\n2.1.10 Dot-dot-dot ¶\nThe ... object type is stored as a type of pairlist. The components of ... can be accessed in the usual pairlist manner from C code, but ... is not easily accessed as an object in interpreted code, and even the existence of such an object should typically not be assumed, as that may change in the future.\nThe object can be captured (with promises being forced!) as a list, so for example in table one sees\n    args &lt;- list(...)\n## ....\n    for (a in args) {\n## ....\nNote that the implementation of ... as a pairlist object is not to be considered part of the R API, and code outside base R should not rely on this current description of .... On the other hand, the above list(...) access, and the other “dot-access” functions ...length(), ...elt(), ...names(), and “reserved words” ..1, ..2, etc, see also help page ?dots, are part of the stable R API.\n \nIf a function has ... as a formal argument then any actual arguments that do not match a formal argument are matched with ....\n\n\n2.1.11 Environments ¶\nEnvironments can be thought of as consisting of two things. A frame, consisting of a set of symbol-value pairs, and an enclosure, a pointer to an enclosing environment. When R looks up the value for a symbol the frame is examined and if a matching symbol is found its value will be returned. If not, the enclosing environment is then accessed and the process repeated. Environments form a tree structure in which the enclosures play the role of parents. The tree of environments is rooted in an empty  environment, available through emptyenv(), which has no parent. It is the direct parent of the environment of the base package  (available through the baseenv() function).\nEnvironments are created implicitly by function calls, as described in Function objects and Lexical environment. In this case the environment contains the variables local to the function (including the arguments), and its enclosure is the environment of the currently called function. Environments may also be created directly by new.env.  The frame content of an environment can be accessed by use of ls, names, $, [, [[, get, and get0,   and manipulated by $&lt;-, [[&lt;-, and assign  as well as eval and evalq.\nThe parent.env function may be used to access the enclosure of an environment.\nUnlike most other R objects, environments are not copied when passed to functions or used in assignments. Thus, if you assign the same environment to several symbols and change one, the others will change too. In particular, assigning attributes to an environment can lead to surprises.\n\n\n2.1.12 Pairlist objects ¶\nPairlist objects are similar to Lisp’s dotted-pair lists. They are used extensively in the internals of R, but are rarely visible in interpreted code, although they are returned by formals, and can be created by (e.g.) the pairlist function. A zero-length pairlist is NULL, as would be expected in Lisp but in contrast to a zero-length list.  Each such object has three slots, a CAR value, a CDR value and a TAG value. The TAG value is a text string and CAR and CDR usually represent, respectively, a list item (head) and the remainder (tail) of the list with a NULL object as terminator (the CAR/CDR terminology is traditional Lisp and originally referred to the address and decrement registers on an early 60’s IBM computer).\nPairlists are handled in the R language in exactly the same way as generic vectors (“lists”). In particular, elements are accessed using the same [[]] syntax. The use of pairlists is deprecated since generic vectors are usually more efficient to use. When an internal pairlist is accessed from R it is generally (including when subsetted) converted to a generic vector.\nIn a very few cases pairlists are user-visible: one is .Options.\n\n\n2.1.13 The “Any” type ¶\nIt is not really possible for an object to be of “Any” type, but it is nevertheless a valid type value. It gets used in certain (rather rare) circumstances, e.g. as.vector(x, \"any\"), indicating that type  coercion should not be done.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects [¶](#objects-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Objects.html#attributes",
    "href": "Objects.html#attributes",
    "title": "2  Objects ¶",
    "section": "2.2 Attributes ¶",
    "text": "2.2 Attributes ¶\n \nAll objects except NULL can have one or more attributes attached to them. Attributes are stored as a pairlist where all elements are named, but should be thought of as a set of name=value pairs. A listing of the attributes can be obtained using attributes and set by attributes&lt;-,   individual components are accessed using attr and attr&lt;-.  \nSome attributes have special accessor  functions (e.g. levels&lt;- for factors) and these should be used when available. In addition to hiding details of implementation they may perform additional operations. R attempts to intercept calls to attr&lt;- and to attributes&lt;- that involve the special attributes and enforces the consistency checks.\nMatrices and arrays are simply vectors with the attribute dim and optionally dimnames attached to the vector.\nAttributes are used to implement the class structure used in R. If an object has a class attribute then that attribute will be examined during  evaluation. The class structure in R is described in detail in Object-oriented programming.\n\n2.2.1 Names ¶\nA names attribute, when present, labels the individual elements of a vector or list. When an object is printed the names attribute, when present, is used to label the elements. The names attribute can also be used for indexing purposes, for example, quantile(x)[\"25%\"].\nOne may get and set the names using names and names&lt;- constructions.    The latter will perform the necessary consistency checks to ensure that the names attribute has the proper type and length.\nPairlists and one-dimensional arrays are treated specially. For pairlist objects, a virtual names attribute is used; the names attribute is really constructed from the tags of the list components. For one-dimensional arrays the names attribute really accesses dimnames[[1]].\n\n\n2.2.2 Dimensions ¶\nThe dim attribute is used to implement arrays. The content of the array is stored in a vector in column-major order and the dim attribute is a vector of integers specifying the respective extents of the array. R ensures that the length of the vector is the product of the lengths of the dimensions. The length of one or more dimensions may be zero.\nA vector is not the same as a one-dimensional array since the latter has a dim attribute of length one, whereas the former has no dim attribute.\n\n\n2.2.3 Dimnames ¶\nArrays may name each dimension separately using the dimnames attribute which is a list of character vectors. The dimnames list may itself have names which are then used for extent headings when printing arrays.\n\n\n2.2.4 Classes ¶\nR has an elaborate class system2, principally controlled via the class attribute. This attribute is a character vector containing the list of classes that an object inherits from. This forms the basis of the “generic methods” functionality in R.\nThis attribute can be accessed and manipulated virtually without restriction by users. There is no checking that an object actually contains the components that class methods expect. Thus, altering the class attribute should be done with caution, and when they are available specific creation and  coercion functions should be preferred.\n\n\n2.2.5 Time series attributes ¶\nThe tsp attribute is used to hold parameters of time series, start, end, and frequency. This construction is mainly used to handle series with periodic substructure such as monthly or quarterly data.\n\n\n2.2.6 Copying of attributes ¶\nWhether attributes should be copied when an object is altered is a complex area, but there are some general rules (Becker, Chambers & Wilks, 1988, pp. 144–6).\nScalar functions (those which operate element-by-element on a vector and whose output is similar to the input) should preserve attributes (except perhaps class).\nBinary operations normally copy most attributes from the longer argument (and if they are of the same length from both, preferring the values on the first). Here ‘most’ means all except the names, dim and dimnames which are set appropriately by the code for the operator.\nSubsetting (other than by an empty index) generally drops all attributes except names, dim and dimnames which are reset as appropriate. On the other hand, subassignment generally preserves attributes even if the length is changed. Coercion drops all attributes.\nThe default method for sorting drops all attributes except names, which are sorted along with the object.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects [¶](#objects-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Objects.html#special-compound-objects",
    "href": "Objects.html#special-compound-objects",
    "title": "2  Objects ¶",
    "section": "2.3 Special compound objects ¶",
    "text": "2.3 Special compound objects ¶\n\n2.3.1 Factors ¶\nFactors are used to describe items that can have a finite number of values (gender, social class, etc.). A factor has a levels attribute and class \"factor\". Optionally, it may also contain a contrasts attribute which controls the parametrisation used when the factor is used in a   modeling functions.\nA factor may be purely nominal or may have ordered categories. In the latter case, it should be defined as such and have a class vector c(\"ordered\",\" factor\").\nFactors are currently implemented using an integer array to specify the actual levels and a second array of names that are mapped to the integers. Rather unfortunately users often make use of the implementation in order to make some calculations easier. This, however, is an implementation issue and is not guaranteed to hold in all implementations of R.\n\n\n2.3.2 Data frame objects ¶\nData frames are the R structures which most closely mimic the SAS or SPSS data set, i.e. a “cases by variables” matrix of data.\nA data frame is a list of vectors, factors, and/or matrices all having the same length (number of rows in the case of matrices). In addition, a data frame generally has a names attribute labeling the variables and a row.names attribute for labeling the cases.\nA data frame can contain a list that is the same length as the other components. The list can contain elements of differing lengths thereby providing a data structure for ragged arrays. However, as of this writing such arrays are not generally handled correctly.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Objects [¶](#objects-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html",
    "href": "Evaluation-of-expressions.html",
    "title": "3  Evaluation of expressions ¶",
    "section": "",
    "text": "3.1 Simple evaluation ¶\nNext: Functions, Previous: Objects, Up: R Language Definition   [Contents][Index]\nWhen a user types a command at the prompt (or when an expression is read from a file) the first thing that happens to it is that the command is transformed by the  parser into an internal representation. The evaluator executes parsed R expressions and returns the value of the expression. All expressions have a value. This is the core of the language.\nThis chapter describes the basic mechanisms of the evaluator, but avoids discussion of specific functions or groups of functions which are described in separate chapters later on or where the help pages should be sufficient documentation.\nUsers can construct expressions and invoke the evaluator on them.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html#simple-evaluation",
    "href": "Evaluation-of-expressions.html#simple-evaluation",
    "title": "3  Evaluation of expressions ¶",
    "section": "",
    "text": "3.1.1 Constants ¶\nAny number typed directly at the prompt is a constant and is evaluated.\n&gt; 1\n[1] 1\nPerhaps unexpectedly, the number returned from the expression 1 is a numeric. In most cases, the difference between an integer and a numeric value will be unimportant as R will do the right thing when using the numbers. There are, however, times when we would like to explicitly create an integer value for a constant. We can do this by calling the function as.integer or using various other techniques. But perhaps the simplest approach is to qualify our constant with the suffix character ‘L’. For example, to create the integer value 1, we might use\n&gt; 1L\n[1] 1\nWe can use the ‘L’ suffix to qualify any number with the intent of making it an explicit integer. So ‘0x10L’ creates the integer value 16 from the hexadecimal representation. The constant 1e3L gives 1000 as an integer rather than a numeric value and is equivalent to 1000L. (Note that the ‘L’ is treated as qualifying the term 1e3 and not the 3.) If we qualify a value with ‘L’ that is not an integer value, e.g. 1e-3L, we get a warning and the numeric value is created. A warning is also created if there is an unnecessary decimal point in the number, e.g. 1.L.\nWe get a syntax error when using ‘L’ with complex numbers, e.g. 12iL gives an error.\nConstants are fairly boring and to do more we need symbols.\n\n\n3.1.2 Symbol lookup ¶\nWhen a new variable is created it must have a  name so it can be referenced and it usually has a value. The name itself is a  symbol. When a symbol is  evaluated its  value is returned. Later we shall explain in detail how to determine the value associated with a symbol.\nIn this small example y is a symbol and its value is 4. A symbol is an R object too, but one rarely needs to deal with symbols directly, except when doing “programming on the language” (Computing on the language).\n&gt; y &lt;- 4\n&gt; y\n[1] 4\n\n\n3.1.3 Function calls ¶\nMost of the computations carried out in R involve the evaluation of functions. We will also refer to this as  function invocation. Functions are invoked by name with a list of arguments separated by commas.\n&gt; mean(1:10)\n[1] 5.5\nIn this example the function mean was called with one argument, the vector of integers from 1 to 10.\nR contains a huge number of functions with different purposes. Most are used for producing a result which is an R object, but others are used for their side effects, e.g., printing and plotting functions.\n \nFunction calls can have tagged (or named) arguments, as in plot(x, y, pch = 3). Arguments without tags are known as positional since the function must distinguish their meaning from their sequential positions among the arguments of the call, e.g., that x denotes the abscissa variable and y the ordinate. The use of tags/names is an obvious convenience for functions with a large number of optional arguments.\nA special type of function calls can appear on the left hand side of the  assignment operator as in\n&gt; class(x) &lt;- \"foo\"\nWhat this construction really does is to call the function class&lt;- with the original object and the right hand side. This function performs the modification of the object and returns the result which is then stored back into the original variable. (At least conceptually, this is what happens. Some additional effort is made to avoid unnecessary data duplication.)\n\n\n3.1.4 Operators ¶\nR allows the use of arithmetic expressions using operators similar to those of the C programming language, for instance\n&gt; 1 + 2\n[1] 3\nExpressions can be grouped using parentheses, mixed with function calls, and assigned to variables in a straightforward manner\n&gt; y &lt;- 2 * (a + log(x))\nR contains a number of operators. They are listed in the table below.\n\n\n\n\n-\nMinus, can be unary or binary\n\n\n+\nPlus, can be unary or binary\n\n\n!\nUnary not\n\n\n~\nTilde, used for model formulae, can be either unary or binary\n\n\n?\nHelp\n\n\n:\nSequence, binary (in model formulae: interaction)\n\n\n*\nMultiplication, binary\n\n\n/\nDivision, binary\n\n\n^\nExponentiation, binary\n\n\n%x%\nSpecial binary operators, x can be replaced by any valid name\n\n\n%%\nModulus, binary\n\n\n%/%\nInteger divide, binary\n\n\n%*%\nMatrix product, binary\n\n\n%o%\nOuter product, binary\n\n\n%x%\nKronecker product, binary\n\n\n%in%\nMatching operator, binary (in model formulae: nesting)\n\n\n%||%\nNull coalescing operator, binary\n\n\n&lt;\nLess than, binary\n\n\n&gt;\nGreater than, binary\n\n\n==\nEqual to, binary\n\n\n&gt;=\nGreater than or equal to, binary\n\n\n&lt;=\nLess than or equal to, binary\n\n\n&\nAnd, binary, vectorized\n\n\n&&\nAnd, binary, not vectorized\n\n\n|\nOr, binary, vectorized\n\n\n||\nOr, binary, not vectorized\n\n\n&lt;-\nLeft assignment, binary\n\n\n-&gt;\nRight assignment, binary\n\n\n$\nList subset, binary\n\n\n\n\nExcept for the syntax, there is no difference between applying an operator and calling a function. In fact, x + y can equivalently be written +(x, y) {.code}. Notice that since +’ is a non-standard function name, it needs to be quoted.\nR deals with entire vectors of data at a time, and most of the elementary operators and basic mathematical functions like log are vectorized (as indicated in the table above). This means that e.g. adding two vectors of the same length will create a vector containing the element-wise sums, implicitly looping over the vector index. This applies also to other operators like -, *, and / as well as to higher dimensional structures. Notice in particular that multiplying two matrices does not produce the usual matrix product (the %*% operator exists for that purpose). Some finer points relating to vectorized operations will be discussed in Elementary arithmetic operations.\nTo access individual elements of an atomic vector, one generally uses the x[i] construction.\n&gt; x &lt;- rnorm(5)\n&gt; x\n[1] -0.12526937 -0.27961154 -1.03718717 -0.08156527  1.37167090\n&gt; x[2]\n[1] -0.2796115\nList components are more commonly accessed using x$a or x[[i]].\n&gt; x &lt;- options()\n&gt; x$prompt\n[1] \"&gt; \"\nIndexing constructs can also appear on the right hand side of an  assignment.\nLike the other operators, indexing is really done by functions, and one could have used [(x, 2) {.code} instead of x[2].\nR’s indexing operations contain many advanced features which are further described in Indexing.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html#control-structures",
    "href": "Evaluation-of-expressions.html#control-structures",
    "title": "3  Evaluation of expressions ¶",
    "section": "3.2 Control structures ¶",
    "text": "3.2 Control structures ¶\nComputation in R consists of sequentially evaluating statements. Statements, such as x&lt;-1:10 or mean(y), can be separated by either a semi-colon or a new line. Whenever the  evaluator is presented with a syntactically complete statement that statement is evaluated and the value returned. The result of evaluating a statement can be referred to as the value of the statement3 The value can always be assigned to a symbol.\nBoth semicolons and new lines can be used to separate statements. A semicolon always indicates the end of a statement while a new line may indicate the end of a statement. If the current statement is not syntactically complete new lines are simply ignored by the evaluator. If the session is interactive the prompt changes from &gt;’ to +’.\n&gt; x &lt;- 0; x + 5\n[1] 5\n&gt; y &lt;- 1:10\n&gt; 1; 2\n[1] 1\n[1] 2\nStatements can be grouped together using braces {’ and }’. A group of statements is sometimes called a block. Single statements are evaluated when a new line is typed at the end of the syntactically complete statement. Blocks are not evaluated until a new line is entered after the closing brace. In the remainder of this section, statement refers to either a single statement or a block.\n&gt; { x &lt;- 0\n+ x + 5\n+ }\n[1] 5\n\n3.2.1 if ¶\nThe if/else statement conditionally evaluates two statements. There is a condition which is evaluated and if the value is TRUE then the first statement is evaluated; otherwise the second statement will be evaluated. The if/else statement returns, as its value, the value of the statement that was selected. The formal syntax is\nif ( statement1 )\n    statement2\nelse\n    statement3\nFirst, statement1 is evaluated to yield value1. If value1 is a logical vector with first element TRUE then statement2 is evaluated. If the first element of value1 is FALSE then statement3 is evaluated. If value1 is a numeric vector then statement3 is evaluated when the first element of value1 is zero and otherwise statement2 is evaluated. Only the first element of value1 is used. All other elements are ignored. If value1 has any type other than a logical or a numeric vector an error is signalled.\nif/else statements can be used to avoid numeric problems such as taking the logarithm of a negative number. Because if/else statements are the same as other statements you can assign the value of them. The two examples below are equivalent.\n&gt; if( any(x &lt;= 0) ) y &lt;- log(1+x) else y &lt;- log(x)\n&gt; y &lt;- if( any(x &lt;= 0) ) log(1+x) else log(x)\nThe else clause is optional. The statement if(any(x &lt;= 0)) x &lt;- x[x &lt;= 0] is valid. When the if statement is not in a block the else, if present, must appear on the same line as the end of statement2. Otherwise the new line at the end of statement2 completes the if and yields a syntactically complete statement that is evaluated. A simple solution is to use a compound statement wrapped in braces, putting the else on the same line as the closing brace that marks the end of the statement.\nif/else statements can be nested.\nif ( statement1 ) {\n    statement2\n} else if ( statement3 ) {\n    statement4\n} else if ( statement5 ) {\n    statement6\n} else\n    statement8\nOne of the even numbered statements will be evaluated and the resulting value returned. If the optional else clause is omitted and all the odd numbered statements evaluate to FALSE no statement will be evaluated and NULL is returned.\nThe odd numbered statements are evaluated, in order, until one evaluates to TRUE and then the associated even numbered statement is evaluated. In this example, statement6 will only be evaluated if statement1 is FALSE and statement3 is FALSE and statement5 is TRUE. There is no limit to the number of else if clauses that are permitted.\n\n\n3.2.2 Looping ¶\nR has three statements that provide explicit looping.4 They are for, while and repeat. The two built-in constructs, next and break, provide additional control over the evaluation. R provides other functions for implicit looping such as tapply, apply, and lapply. In addition many operations, especially arithmetic ones, are vectorized so you may not need to use a loop.\nThere are two statements that can be used to explicitly control looping. They are break and next.   The break statement causes an exit from the innermost loop that is currently being executed. The next statement immediately causes control to return to the start of the loop. The next iteration of the loop (if there is one) is then executed. No statement below next in the current loop is evaluated.\nThe value returned by a loop statement is always NULL and is returned invisibly.\n\n\n3.2.3 repeat ¶\nThe repeat statement causes repeated evaluation of the body until a break is specifically requested. This means that you need to be careful when using repeat because of the danger of an infinite loop. The syntax of the repeat loop is\nrepeat statement\nWhen using repeat, statement must be a block statement. You need to both perform some computation and test whether or not to break from the loop and usually this requires two statements.\n\n\n3.2.4 while ¶\nThe while statement is very similar to the repeat statement. The syntax of the while loop is\nwhile ( statement1 ) statement2\nwhere statement1 is evaluated and if its value is TRUE then statement2 is evaluated. This process continues until statement1 evaluates to FALSE.\n\n\n3.2.5 for ¶\nThe syntax of the for loop is\nfor ( name in vector )\n   statement1\nwhere vector can be either a vector or a list. For each element in vector the variable name is set to the value of that element and statement1 is evaluated. A side effect is that the variable name still exists after the loop has concluded and it has the value of the last element of vector that the loop was evaluated for.\n\n\n3.2.6 switch ¶\nTechnically speaking, switch is just another function, but its semantics are close to those of control structures of other programming languages.\nThe syntax is\nswitch (statement, list)\nwhere the elements of list may be named. First, statement is evaluated and the result, value, obtained. If value is a number between 1 and the length of list then the corresponding element of list is evaluated and the result returned. If value is too large or too small NULL is returned.\n&gt; x &lt;- 3\n&gt; switch(x, 2+2, mean(1:10), rnorm(5))\n[1]  2.2903605  2.3271663 -0.7060073  1.3622045 -0.2892720\n&gt; switch(2, 2+2, mean(1:10), rnorm(5))\n[1] 5.5\n&gt; switch(6, 2+2, mean(1:10), rnorm(5))\nNULL\nIf value is a character vector then the element of ... with a name that exactly matches value is evaluated. If there is no match a single unnamed argument will be used as a default. If no default is specified, NULL is returned.\n&gt; y &lt;- \"fruit\"\n&gt; switch(y, fruit = \"banana\", vegetable = \"broccoli\", \"Neither\")\n[1] \"banana\"\n&gt; y &lt;- \"meat\"\n&gt; switch(y, fruit = \"banana\", vegetable = \"broccoli\", \"Neither\")\n[1] \"Neither\"\nA common use of switch is to branch according to the character value of one of the arguments to a function.\n&gt; centre &lt;- function(x, type) {\n+ switch(type,\n+        mean = mean(x),\n+        median = median(x),\n+        trimmed = mean(x, trim = .1))\n+ }\n&gt; x &lt;- rcauchy(10)\n&gt; centre(x, \"mean\")\n[1] 0.8760325\n&gt; centre(x, \"median\")\n[1] 0.5360891\n&gt; centre(x, \"trimmed\")\n[1] 0.6086504\nswitch returns either the value of the statement that was evaluated or NULL if no statement was evaluated.\nTo choose from a list of alternatives that already exists switch may not be the best way to select one for evaluation. It is often better to use eval and the subset operator, [[, directly via eval(x[[condition]]).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html#elementary-arithmetic-operations",
    "href": "Evaluation-of-expressions.html#elementary-arithmetic-operations",
    "title": "3  Evaluation of expressions ¶",
    "section": "3.3 Elementary arithmetic operations ¶",
    "text": "3.3 Elementary arithmetic operations ¶\nIn this section, we discuss the finer points of the rules that apply to basic operation like addition or multiplication of two vectors or matrices.\n\n3.3.1 Recycling rules ¶\nIf one tries to add two structures with a different number of elements, then the shortest is recycled to length of longest. That is, if for instance you add c(1, 2, 3) to a six-element vector then you will really add c(1, 2, 3, 1, 2, 3). If the length of the longer vector is not a multiple of the shorter one, a warning is given.\nAs from R 1.4.0, any arithmetic operation involving a zero-length vector has a zero-length result.\n\n\n3.3.2 Propagation of names ¶\npropagation of names (first one wins, I think - also if it has no names?? —- first one *with names* wins, recycling causes shortest to lose names)\n\n\n3.3.3 Dimensional attributes ¶\n(matrix+matrix, dimensions must match. vector+matrix: first recycle, then check if dims fit, error if not)\n\n\n3.3.4 NA handling ¶\nMissing values in the statistical sense, that is, variables whose value is not known, have the value NA. This should not be confused with the missing property for a function argument that has not been supplied (see Arguments).\nAs the elements of an atomic vector must be of the same type there are multiple types of NA values. There is one case where this is particularly important to the user. The default type of NA is logical, unless coerced to some other type, so the appearance of a missing value may trigger logical rather than numeric indexing (see Indexing for details).\nNumeric and logical calculations with NA generally return NA. In cases where the result of the operation would be the same for all possible values the NA could take, the operation may return this value. In particular, FALSE & NA’ is FALSE, TRUE | NA’ is TRUE. NA is not equal to any other value or to itself; testing for NA is done using is.na.  However, an NA value will match another NA value in match.\nNumeric calculations whose result is undefined, such as 0/0’, produce the value NaN. This exists only in the double type and for real or imaginary components of the complex type. The function is.nan is provided to check specifically for  NaN, is.na also returns TRUE for NaN.  Coercing NaN to logical or integer type gives an NA of the appropriate type, but coercion to character gives the string \"NaN\". NaN values are incomparable so tests of equality or collation involving NaN will result in NA. They are regarded as matching any NaN value (and no other value, not even NA) by match.\nThe NA of character type is distinct from the string \"NA\". Programmers who need to specify an explicit string NA should use NA_character_’ rather than \"NA\", or set elements to NA using is.na&lt;-.\nThe constants NA_integer_, NA_real_, NA_complex_ and NA_character_ will generate (in the parser) an NA value of the appropriate type, and will be used in deparsing when it is not otherwise possible to identify the type of an NA (and the control options ask for this to be done).\nThere is no NA value for raw vectors.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html#indexing",
    "href": "Evaluation-of-expressions.html#indexing",
    "title": "3  Evaluation of expressions ¶",
    "section": "3.4 Indexing ¶",
    "text": "3.4 Indexing ¶\nR contains several constructs which allow access to individual elements or subsets through indexing operations. In the case of the basic vector types one can access the i-th element using x[i], but there is also indexing of lists, matrices, and multi-dimensional arrays. There are several forms of indexing in addition to indexing with a single integer. Indexing can be used both to extract part of an object and to replace parts of an object (or to add parts).\nR has three basic indexing operators, with syntax displayed by the following examples\nx[i]\nx[i, j]\nx[[i]]\nx[[i, j]]\nx$a\nx$\"a\"\nFor vectors and matrices the [[ forms are rarely used, although they have some slight semantic differences from the [ form (e.g. it drops any names or dimnames attribute, and that partial matching is used for character indices). When indexing multi-dimensional structures with a single index, x[[i]] or x[i] will return the i-th sequential element of x.\nFor lists, one generally uses [[ to select any single element, whereas [ returns a list of the selected elements.\nThe [[ form allows only a single element to be selected using integer or character indices, whereas [ allows indexing by vectors. Note though that for a list or other recursive object, the index can be a vector and each element of the vector is applied in turn to the list, the selected component, the selected component of that component, and so on. The result is still a single element.\nThe form using $ applies to recursive objects such as lists and pairlists. It allows only a literal character string or a symbol as the index. That is, the index is not computable: for cases where you need to evaluate an expression to find the index, use x[[expr]]. Applying $ to a non-recursive object is an error.\n\n3.4.1 Indexing by vectors ¶\nR allows some powerful constructions using vectors as indices. We shall discuss indexing of simple vectors first. For simplicity, assume that the expression is x[i]. Then the following possibilities exist according to the type of i.\n\n Integer. All elements of i must have the same sign. If they are positive, the elements of x with those index numbers are selected. If i contains negative elements, all elements except those indicated are selected.\nIf i is positive and exceeds length(x) then the corresponding selection is NA. Negative out of bounds values for i are silently disregarded since R version 2.6.0, S compatibly, as they mean to drop non-existing elements and that is an empty operation (“no-op”).\nA special case is the zero index, which has null effects: x[0] is an empty vector and otherwise including zeros among positive or negative indices has the same effect as if they were omitted.\nOther numeric. Non-integer values are converted to integer (by truncation towards zero) before use.\nLogical. The indexing i should generally have the same length as x. If it is shorter, then its elements will be recycled as discussed in Elementary arithmetic operations. If it is longer, then x is conceptually extended with NAs. The selected values of x are those for which i is TRUE.\n Character. The strings in i are matched against the names attribute of x and the resulting integers are used. For [[ and $ partial matching is used if exact matching fails, so x$aa will match x$aabb if x does not contain a component named \"aa\" and \"aabb\" is the only name which has prefix \"aa\". For [[, partial matching can be controlled via the exact argument which defaults to NA indicating that partial matching is allowed, but should result in a warning when it occurs. Setting exact to TRUE prevents partial matching from occurring, a FALSE value allows it and does not issue any warnings. Note that [ always requires an exact match. The string \"\" is treated specially: it indicates ‘no name’ and matches no element (not even those without a name). Note that partial matching is only used when extracting and not when replacing.\nFactor. The result is identical to x[as.integer(i)]. The factor levels are never used. If so desired, use x[as.character(i)] or a similar construction.\nEmpty. The expression x[] returns x, but drops “irrelevant” attributes from the result. Only names and in multi-dimensional arrays dim and dimnames attributes are retained.\nNULL. This is treated as if it were integer(0).\n\nIndexing with a missing (i.e. NA) value gives an NA result. This rule applies also to the case of logical indexing, i.e. the elements of x that have an NA selector in i get included in the result, but their value will be NA.\nNotice however, that there are different modes of NA—the literal constant is of mode \"logical\", but it is frequently automatically coerced to other types. One effect of this is that x[NA] has the length of x, but x[c(1, NA)] has length 2. That is because the rules for logical indices apply in the former case, but those for integer indices in the latter.\nIndexing with [ will also carry out the relevant subsetting of any names attributes.\n\n\n3.4.2 Indexing matrices and arrays ¶\nSubsetting multi-dimensional structures generally follows the same rules as single-dimensional indexing for each index variable, with the relevant component of dimnames taking the place of names. A couple of special rules apply, though:\nNormally, a structure is accessed using the number of indices corresponding to its dimension. It is however also possible to use a single index in which case the dim and dimnames attributes are disregarded and the result is effectively that of c(m)[i]. Notice that m[1] is usually very different from m[1, ] or m[, 1].\nIt is possible to use a matrix of integers as an index. In this case, the number of columns of the matrix should match the number of dimensions of the structure, and the result will be a vector with length as the number of rows of the matrix. The following example shows how to extract the elements m[1, 1] and m[2, 2] in one operation.\n&gt; m &lt;- matrix(1:4, 2)\n&gt; m\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n&gt; i &lt;- matrix(c(1, 1, 2, 2), 2, byrow = TRUE)\n&gt; i\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n&gt; m[i]\n[1] 1 4\nIndexing matrices may not contain negative indices. NA and zero values are allowed: rows in an index matrix containing a zero are ignored, whereas rows containing an NA produce an NA in the result.\nBoth in the case of using a single  index and in matrix indexing, a names attribute is used if present, as had the structure been one-dimensional.\nIf an indexing operation causes the result to have one of its extents of length one, as in selecting a single slice of a three-dimensional matrix with (say) m[2, , ], the corresponding dimension is generally dropped from the result. If a single-dimensional structure results, a vector is obtained. This is occasionally undesirable and can be turned off by adding the drop = FALSE’ to the indexing operation. Notice that this is an additional argument to the [ function and doesn’t add to the index count. Hence the correct way of selecting the first row of a matrix as a 1 by n matrix is m[1, , drop = FALSE]. Forgetting to disable the dropping feature is a common cause of failure in general subroutines where an index occasionally, but not usually has length one. This rule still applies to a one-dimensional array, where any subsetting will give a vector result unless drop = FALSE’ is used.\nNotice that vectors are distinct from one-dimensional arrays in that the latter have dim and dimnames attributes (both of length one). One-dimensional arrays are not easily obtained from subsetting operations but they can be constructed explicitly and are returned by table. This is sometimes useful because the elements of the dimnames list may themselves be named, which is not the case for the names attribute.\nSome operations such as m[FALSE, ] result in structures in which a dimension has zero extent. R generally tries to handle these structures sensibly.\n\n\n3.4.3 Indexing other structures ¶\nThe operator [ is a generic function which allows class methods to be added, and the $ and [[ operators likewise. Thus, it is possible to have user-defined indexing operations for any structure. Such a function, say [.foo is called with a set of arguments of which the first is the structure being indexed and the rest are the indices. In the case of $, the index argument is of mode \"symbol\" even when using the x$\"abc\" form. It is important to be aware that class methods do not necessarily behave in the same way as the basic methods, for example with respect to partial matching.\nThe most important example of a class method for [ is that used for data frames. It is not described in detail here (see the help page for [.data.frame), but in broad terms, if two indices are supplied (even if one is empty) it creates matrix-like indexing for a structure that is basically a list of vectors of the same length. If a single index is supplied, it is interpreted as indexing the list of columns—in that case the drop argument is ignored, with a warning.\nThe basic operators $ and [[ can be applied to environments. Only character indices are allowed and no partial matching is done.\n\n\n3.4.4 Subset assignment ¶\n \nAssignment to subsets of a structure is a special case of a general mechanism for complex assignment:\nx[3:5] &lt;- 13:15\nThe result of this command is as if the following had been executed\n`*tmp*` &lt;- x\nx &lt;- \"[&lt;-\"(`*tmp*`, 3:5, value=13:15)\nrm(`*tmp*`)\nNote that the index is first converted to a numeric index and then the elements are replaced sequentially along the numeric index, as if a for loop had been used. Any existing variable called *tmp* {.code} will be overwritten and deleted, and this variable name should not be used in code.\nThe same mechanism can be applied to functions other than [. The replacement function has the same name with &lt;- pasted on. Its last argument, which must be called value, is the new value to be assigned. For example,\nnames(x) &lt;- c(\"a\",\"b\")\nis equivalent to\n`*tmp*` &lt;- x\nx &lt;- \"names&lt;-\"(`*tmp*`, value=c(\"a\",\"b\"))\nrm(`*tmp*`)\nNesting of complex assignments is evaluated recursively\nnames(x)[3] &lt;- \"Three\"\nis equivalent to\n`*tmp*` &lt;- x\nx &lt;- \"names&lt;-\"(`*tmp*`, value=\"[&lt;-\"(names(`*tmp*`), 3, value=\"Three\"))\nrm(`*tmp*`)\nComplex assignments in the enclosing environment (using &lt;&lt;-) are also permitted:\nnames(x)[3] &lt;&lt;- \"Three\"\nis equivalent to\n`*tmp*` &lt;&lt;- get(x, envir=parent.env(), inherits=TRUE)\nnames(`*tmp*`)[3] &lt;- \"Three\"\nx &lt;&lt;- `*tmp*`\nrm(`*tmp*`)\nand also to\n`*tmp*` &lt;- get(x,envir=parent.env(), inherits=TRUE)\nx &lt;&lt;- \"names&lt;-\"(`*tmp*`, value=\"[&lt;-\"(names(`*tmp*`), 3, value=\"Three\"))\nrm(`*tmp*`)\nOnly the target variable is evaluated in the enclosing environment, so\ne&lt;-c(a=1,b=2)\ni&lt;-1\nlocal({\n   e &lt;- c(A=10,B=11)\n   i &lt;-2\n   e[i] &lt;&lt;- e[i]+1\n})\nuses the local value of i on both the LHS and RHS, and the local value of e on the RHS of the superassignment statement. It sets e in the outer environment to\n a  b \n 1 12\nThat is, the superassignment is equivalent to the four lines\n`*tmp*` &lt;- get(e, envir=parent.env(), inherits=TRUE)\n`*tmp*`[i] &lt;- e[i]+1\ne &lt;&lt;- `*tmp*`\nrm(`*tmp*`)\nSimilarly\nx[is.na(x)] &lt;&lt;- 0\nis equivalent to\n`*tmp*` &lt;- get(x,envir=parent.env(), inherits=TRUE)\n`*tmp*`[is.na(x)] &lt;- 0\nx &lt;&lt;- `*tmp*`\nrm(`*tmp*`)\nand not to\n`*tmp*` &lt;- get(x,envir=parent.env(), inherits=TRUE)\n`*tmp*`[is.na(`*tmp*`)] &lt;- 0\nx &lt;&lt;- `*tmp*`\nrm(`*tmp*`)\nThese two candidate interpretations differ only if there is also a local variable x. It is a good idea to avoid having a local variable with the same name as the target variable of a superassignment. As this case was handled incorrectly in versions 1.9.1 and earlier there must not be a serious need for such code.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Evaluation-of-expressions.html#scope-of-variables",
    "href": "Evaluation-of-expressions.html#scope-of-variables",
    "title": "3  Evaluation of expressions ¶",
    "section": "3.5 Scope of variables ¶",
    "text": "3.5 Scope of variables ¶\nAlmost every programming language has a set of scoping rules, allowing the same name to be used for different objects. This allows, e.g., a local variable in a function to have the same name as a global object.\nR uses a lexical scoping model, similar to languages like Pascal. However, R is a functional programming language and allows dynamic creation and manipulation of functions and language objects, and has additional features reflecting this fact.\n\n3.5.1 Global environment ¶\nThe global  environment is the root of the user workspace. An  assignment operation from the command line will cause the relevant object to belong to the global environment. Its enclosing environment is the next environment on the search path, and so on back to the empty environment that is the enclosure of the base environment.\n\n\n3.5.2 Lexical environment ¶\nEvery call to a  function creates a   frame which contains the local variables created in the function, and is evaluated in an environment, which in combination creates a new environment.\nNotice the terminology: A frame is a set of variables, an environment is a nesting of frames (or equivalently: the innermost frame plus the enclosing environment).\nEnvironments may be assigned to variables or be contained in other objects. However, notice that they are not standard objects—in particular, they are not copied on assignment.\nA closure (mode \"function\") object will contain the environment in which it is created as part of its definition (By default. The environment can be manipulated using environment&lt;-). When the function is subsequently called, its  evaluation environment is created with the closure’s environment as enclosure. Notice that this is not necessarily the environment of the caller!\nThus, when a variable is requested inside a  function, it is first sought in the  evaluation environment, then in the enclosure, the enclosure of the enclosure, etc.; once the global environment or the environment of a package is reached, the search continues up the search path to the environment of the base package. If the variable is not found there, the search will proceed next to the empty environment, and will fail.\n\n\n3.5.3 The call stack ¶\nEvery time a  function is invoked a new evaluation frame is created. At any point in time during the computation the currently active environments are accessible through the call stack. Each time a function is invoked a special construct called a context is created internally and is placed on a list of contexts. When a function has finished evaluating its context is removed from the call stack.\nMaking variables defined higher up the call stack available is called  dynamic scope. The binding for a variable is then determined by the most recent (in time) definition of the variable. This contradicts the default scoping rules in R, which use the bindings in the  environment in which the function was defined (lexical scope). Some functions, particularly those that use and manipulate model formulas, need to simulate dynamic scope by directly accessing the call stack.\nAccess to the  call stack is provided through a family of functions which have names that start with sys.’. They are listed briefly below.\n\nsys.call\n\nGet the call for the specified context.\n\nsys.frame\n\nGet the evaluation frame for the specified context.\n\nsys.nframe\n\nGet the environment frame for all active contexts.\n\nsys.function\n\nGet the function being invoked in the specified context.\n\nsys.parent\n\nGet the parent of the current function invocation.\n\nsys.calls\n\nGet the calls for all the active contexts.\n\nsys.frames\n\nGet the evaluation frames for all the active contexts.\n\nsys.parents\n\nGet the numeric labels for all active contexts.\n\nsys.on.exit\n\nSet a function to be executed when the specified context is exited.\n\nsys.status\n\nCalls sys.frames, sys.parents and sys.calls.\n\nparent.frame\n\nGet the evaluation frame for the specified parent context.\n\n\n\n\n3.5.4 Search path ¶\nIn addition to the evaluation   environment structure, R has a search path of environments which are searched for variables not found elsewhere. This is used for two things: packages of functions and attached user data.\nThe first element of the search path is the global environment and the last is the base package. An Autoloads environment is used for holding proxy objects that may be loaded on demand. Other environments are inserted in the path using attach or library.\nPackages which have a namespace have a different search path. When a search for an R object is started from an object in such a package, the package itself is searched first, then its imports, then the base namespace and finally the global environment and the rest of the regular search path. The effect is that references to other objects in the same package will be resolved to the package, and objects cannot be masked by objects of the same name in the global environment or in other packages.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Evaluation of expressions [¶](#evaluation-of-expressions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Functions.html",
    "href": "Functions.html",
    "title": "4  Functions ¶",
    "section": "",
    "text": "4.1 Writing functions ¶\nNext: Object-oriented programming, Previous: Evaluation of expressions, Up: R Language Definition   [Contents][Index]\nWhile R can be very useful as a data analysis tool most users very quickly find themselves wanting to write their own  functions. This is one of the real advantages of R. Users can program it and they can, if they want to, change the system level functions to functions that they find more appropriate.\nR also provides facilities that make it easy to document any functions that you have created. See Writing R documentation in Writing R Extensions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions [¶](#functions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Functions.html#writing-functions",
    "href": "Functions.html#writing-functions",
    "title": "4  Functions ¶",
    "section": "",
    "text": "4.1.1 Syntax and examples ¶\nThe syntax for writing a  function is\nfunction ( arglist ) body\nThe first component of the function declaration is the keyword function which indicates to R that you want to create a function.\nAn  argument list is a comma separated list of formal arguments. A formal argument can be a symbol, a statement of the form symbol=expression’, or the special formal argument ....\nThe body can be any valid R expression. Generally, the body is a group of expressions contained in curly braces ({’ and }’).\nGenerally  functions are assigned to symbols but they don’t need to be. The value returned by the call to function is a function. If this is not given a name it is referred to as an  anonymous function. Anonymous functions are most frequently used as arguments to other functions such as the apply family or outer.\nHere is a simple function: echo &lt;- function(x) print(x). So echo is a function that takes a single argument and when echo is invoked it prints its argument.\n\n\n4.1.2 Arguments ¶\nThe formal arguments to the function define the variables whose values will be supplied at the time the function is invoked. The names of these arguments can be used within the function body where they obtain the value supplied at the time of function invocation.\nDefault values for arguments can be specified using the special form name=expression’. In this case, if the user does not specify a value for the argument when the function is invoked the expression will be associated with the corresponding symbol. When a value is needed the expression is  evaluated in the evaluation frame of the function.\nDefault behaviours can also be specified by using the function missing. When missing is called with the  name of a formal argument it returns TRUE if the formal argument was not matched with any actual argument and has not been subsequently modified in the body of the function. An argument that is missing will thus have its default value, if any. The missing function does not force evaluation of the argument.\nThe special type of argument ... can contain any number of supplied arguments. It is used for a variety of purposes. It allows you to write a  function that takes an arbitrary number of arguments. It can be used to absorb some arguments into an intermediate function which can then be extracted by functions called subsequently.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions [¶](#functions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Functions.html#functions-as-objects",
    "href": "Functions.html#functions-as-objects",
    "title": "4  Functions ¶",
    "section": "4.2 Functions as objects ¶",
    "text": "4.2 Functions as objects ¶\nFunctions are first class objects in R. They can be used anywhere that an R object is required. In particular they can be passed as arguments to functions and returned as values from functions. See Function objects for the details.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions [¶](#functions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Functions.html#evaluation",
    "href": "Functions.html#evaluation",
    "title": "4  Functions ¶",
    "section": "4.3 Evaluation ¶",
    "text": "4.3 Evaluation ¶\n\n4.3.1 Evaluation environment ¶\nWhen a  function is called or invoked a new  evaluation frame is created. In this frame the formal arguments are matched with the supplied arguments according to the rules given in Argument matching. The statements in the body of the function are evaluated sequentially in this  environment frame.\nThe enclosing frame of the evaluation frame is the environment frame associated with the function being invoked. This may be different from S. While many functions have .GlobalEnv as their environment this does not have to be true and functions defined in packages with namespaces (normally) have the package namespace as their environment.\n\n\n4.3.2 Argument matching ¶\nThis subsection applies to closures but not to primitive functions. The latter typically ignore tags and do positional matching, but their help pages should be consulted for exceptions, which include log, round, signif, rep and seq.int.\nThe first thing that occurs in a  function evaluation is the matching of formal to the actual or supplied arguments. This is done by a three-pass process:\n\nExact matching on tags.  For each named supplied argument the list of formal arguments is searched for an item whose name matches exactly. It is an error to have the same formal argument match several actuals or vice versa.\nPartial matching on tags. Each remaining named supplied argument is compared to the remaining formal arguments using partial matching. If the name of the supplied argument matches exactly with the first part of a formal argument then the two arguments are considered to be matched. It is an error to have multiple partial matches. Notice that if f &lt;- function(fumble, fooey) fbody, then f(f = 1, fo = 2) is illegal, even though the 2nd actual argument only matches fooey. f(f = 1, fooey = 2) is legal though since the second argument matches exactly and is removed from consideration for partial matching. If the formal arguments contain ... then partial matching is only applied to arguments that precede it.\nPositional matching. Any unmatched formal arguments are bound to unnamed supplied arguments, in order. If there is a ... argument, it will take up the remaining arguments, tagged or not.\n\nIf any arguments remain unmatched an error is declared.\nArgument matching is augmented by the functions match.arg, match.call and match.fun.    Access to the partial matching algorithm used by R is via pmatch.\n\n\n4.3.3 Argument evaluation ¶\nOne of the most important things to know about the  evaluation of arguments to a  function is that supplied arguments and default arguments are treated differently. The supplied arguments to a function are evaluated in the evaluation frame of the calling function. The default arguments to a function are evaluated in the evaluation frame of the function.\nThe semantics of invoking a function in R argument are call-by-value. In general, supplied arguments behave as if they are local variables initialized with the value supplied and the  name of the corresponding formal argument. Changing the value of a supplied argument within a function will not affect the value of the variable in the calling frame.\nR has a form of lazy evaluation of function arguments. Arguments are not evaluated until needed. It is important to realize that in some cases the argument will never be evaluated. Thus, it is bad style to use arguments to functions to cause side-effects. While in C it is common to use the form, foo(x = y) to invoke foo with the value of y and simultaneously to assign the value of y to x this same style should not be used in R. There is no guarantee that the argument will ever be evaluated and hence the  assignment may not take place.\nIt is also worth noting that the effect of foo(x &lt;- y) if the argument is evaluated is to change the value of x in the calling  environment and not in the  evaluation environment of foo.\nIt is possible to access the actual (not default) expressions used as arguments inside the function. The mechanism is implemented via promises. When a  function is being evaluated the actual expression used as an argument is stored in the promise together with a pointer to the environment the function was called from. When (if) the argument is evaluated the stored expression is evaluated in the environment that the function was called from. Since only a pointer to the environment is used any changes made to that environment will be in effect during this evaluation. The resulting value is then also stored in a separate spot in the promise. Subsequent evaluations retrieve this stored value (a second evaluation is not carried out). Access to the unevaluated expression is also available using substitute.\nWhen a  function is called, each formal argument is assigned a promise in the local environment of the call with the expression slot containing the actual argument (if it exists) and the environment slot containing the environment of the caller. If no actual argument for a formal argument is given in the call and there is a default expression, it is similarly assigned to the expression slot of the formal argument, but with the  environment set to the local environment.\nThe process of filling the value slot of a promise by  evaluating the contents of the expression slot in the promise’s environment is called forcing the promise. A promise will only be forced once, the value slot content being used directly later on.\nA promise is forced when its value is needed. This usually happens inside internal   functions, but a promise can also be forced by direct evaluation of the promise itself. This is occasionally useful when a default expression depends on the value of another formal argument or other variable in the local environment. This is seen in the following example where the lone label ensures that the label is based on the value of x before it is changed in the next line.\nfunction(x, label = deparse(x)) {\n    label\n    x &lt;- x + 1\n    print(label)\n}\nThe expression slot of a promise can itself involve other promises. This happens whenever an unevaluated argument is passed as an argument to another function. When forcing a promise, other promises in its expression will also be forced recursively as they are evaluated.\n\n\n4.3.4 Scope ¶\nScope or the scoping rules are simply the set of rules used by the  evaluator to find a value for a  symbol. Every computer language has a set of such rules. In R the rules are fairly simple but there do exist mechanisms for subverting the usual, or default rules.\nR adheres to a set of rules that are called lexical scope. This means the variable  bindings in effect at the time the expression was created are used to provide values for any unbound symbols in the expression.\nMost of the interesting properties of  scope are involved with evaluating  functions and we concentrate on this issue. A symbol can be either  bound or unbound. All of the formal arguments to a function provide bound symbols in the body of the function. Any other symbols in the body of the function are either local variables or unbound variables. A local variable is one that is defined within the function. Because R has no formal definition of variables, they are simply used as needed, it can be difficult to determine whether a variable is local or not. Local variables must first be defined, this is typically done by having them on the left-hand side of an  assignment.\nDuring the evaluation process if an unbound symbol is detected then R attempts to find a value for it. The scoping rules determine how this process proceeds. In R the  environment of the function is searched first, then its enclosure and so on until the global environment is reached.\nThe global environment heads a search list of environments that are searched sequentially for a matching symbol. The value of the first match is then used.\nWhen this set of rules is combined with the fact that  functions can be returned as values from other functions then some rather nice, but at first glance peculiar, properties obtain.\nA simple example:\nf &lt;- function() {\n    y &lt;- 10\n    g &lt;- function(x) x + y\n    return(g)\n}\nh &lt;- f()\nh(3)\nA rather interesting question is what happens when h is evaluated. When a function body is evaluated there is no problem determining values for local variables or for bound variables. Scoping rules determine how the language will find values for the unbound variables.\nWhen h(3) is evaluated we see that its body is that of g. Within that body x is bound to the formal argument and y is unbound. In a language with  lexical scope x will be associated with the value 3 and y with the value 10 local to f so h(3) should return the value 13. In R this is indeed what happens.\nIn S, because of the different scoping rules one will get an error indicating that y is not found, unless there is a variable y in your workspace in which case its value will be used.\nNext: Object-oriented programming, Previous: Evaluation of expressions, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions [¶](#functions-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html",
    "href": "Object-oriented-programming.html",
    "title": "5  Object-oriented programming ¶",
    "section": "",
    "text": "5.1 Definition ¶\nNext: Computing on the language, Previous: Functions, Up: R Language Definition   [Contents][Index]\nObject-oriented programming is a style of programming that has become popular in recent years. Much of the popularity comes from the fact that it makes it easier to write and maintain complicated systems. It does this through several different mechanisms.\nCentral to any object-oriented language are the concepts of class and of methods. A class is a definition of an object. Typically a class contains several slots that are used to hold class-specific information. An object in the language must be an instance of some class. Programming is based on objects or instances of classes.\nComputations are carried out via methods. Methods are basically  functions that are specialized to carry out specific calculations on objects, usually of a specific class. This is what makes the language object oriented. In R, generic functions are used to determine the appropriate method. The generic function is responsible for determining the class of its argument(s) and uses that information to select the appropriate method.\nAnother feature of most object-oriented languages is the concept of inheritance. In most programming problems there are usually many objects that are related to one another. The programming is considerably simplified if some components can be reused.\nIf a class inherits from another class then generally it gets all the slots in the parent class and can extend it by adding new slots. On method dispatching (via the generic functions) if a method for the class does not exist then a method for the parent is sought.\nIn this chapter we discuss how this general strategy has been implemented in R and discuss some of the limitations within the current design. One of the advantages that most object systems impart is greater consistency. This is achieved via the rules that are checked by the compiler or interpreter. Unfortunately because of the way that the object system is incorporated into R this advantage does not obtain. Users are cautioned to use the object system in a straightforward manner. While it is possible to perform some rather interesting feats these tend to lead to obfuscated code and may depend on implementation details that will not be carried forward.\nThe greatest use of object oriented programming in R is through print methods, summary methods and plot methods. These methods allow us to have one generic  function call, plot say, that dispatches on the type of its argument and calls a plotting function that is specific to the data supplied.\nIn order to make the concepts clear we will consider the implementation of a small system designed to teach students about probability. In this system the objects are probability functions and the methods we will consider are methods for finding moments and for plotting. Probabilities can always be represented in terms of the cumulative distribution function but can often be represented in other ways. For example as a density, when it exists or as a moment generating function when it exists.\nRather than having a full-fledged  object-oriented system R has a class system and a mechanism for dispatching based on the class of an object. The dispatch mechanism for interpreted code relies on four special objects that are stored in the evaluation frame. These special objects are .Generic, .Class, .Method and .Group. There is a separate dispatch mechanism used for internal functions and types that will be discussed elsewhere.\nThe class system is facilitated through the class attribute. This attribute is a character vector of class names. So to create an object of class \"foo\" one simply attaches a class attribute with the string \"foo\"’ in it. Thus, virtually anything can be turned in to an object of class \"foo\".\nThe object system makes use of  generic functions via two dispatching functions, UseMethod and NextMethod. The typical use of the object system is to begin by calling a generic function. This is typically a very simple function and consists of a single line of code. The system function mean is just such a function,\nWhen mean is called it can have any number of arguments but its first argument is special and the class of that first argument is used to determine which method should be called. The variable .Class is set to the class attribute of x, .Generic is set to the string \"mean\" and a search is made for the correct method to invoke. The class attributes of any other arguments to mean are ignored.\nSuppose that x had a class attribute that contained \"foo\" and \"bar\", in that order. Then R would first search for a function called mean.foo and if it did not find one it would then search for a function mean.bar and if that search was also unsuccessful then a final search for mean.default would be made. If the last search is unsuccessful R reports an error. It is a good idea to always write a default method. Note that the functions mean.foo etc. are referred to, in this context, as methods.\nNextMethod provides another mechanism for dispatching. A  function may have a call to NextMethod anywhere in it. The determination of which method should then be invoked is based primarily on the current values of .Class and .Generic. This is somewhat problematic since the method is really an ordinary function and users may call it directly. If they do so then there will be no values for .Generic or .Class.\nIf a method is invoked directly and it contains a call to NextMethod then the first argument to NextMethod is used to determine the  generic function. An error is signalled if this argument has not been supplied; it is therefore a good idea to always supply this argument.\nIn the case that a method is invoked directly the class attribute of the first argument to the method is used as the value of .Class.\nMethods themselves employ NextMethod to provide a form of inheritance. Commonly a specific method performs a few operations to set up the data and then it calls the next appropriate method through a call to NextMethod.\nConsider the following simple example. A point in two-dimensional Euclidean space can be specified by its Cartesian (x-y) or polar (r-theta) coordinates. Hence, to store information about the location of the point, we could define two classes, \"xypoint\" and \"rthetapoint\". All the ‘xypoint’ data structures are lists with an x-component and a y-component. All ‘rthetapoint’ objects are lists with an r-component and a theta-component.\nNow, suppose we want to get the x-position from either type of object. This can easily be achieved through  generic functions. We define the generic function xpos as follows.\nNow we can define methods:\nThe user simply calls the function xpos with either representation as the argument. The internal dispatching method finds the class of the object and calls the appropriate methods.\nIt is pretty easy to add other representations. One need not write a new generic function only the methods. This makes it easy to add to existing systems since the user is only responsible for dealing with the new representation and not with any of the existing representations.\nThe bulk of the uses of this methodology are to provide specialized printing for objects of different types; there are about 40 methods for print.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#definition",
    "href": "Object-oriented-programming.html#definition",
    "title": "5  Object-oriented programming ¶",
    "section": "",
    "text": "&gt; mean\nfunction (x, ...)\nUseMethod(\"mean\")\n\n\n\n\n\n\n\n\nxpos &lt;- function(x, ...)\n    UseMethod(\"xpos\")\n\nxpos.xypoint &lt;- function(x) x$x\nxpos.rthetapoint &lt;- function(x) x$r * cos(x$theta)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#inheritance",
    "href": "Object-oriented-programming.html#inheritance",
    "title": "5  Object-oriented programming ¶",
    "section": "5.2 Inheritance ¶",
    "text": "5.2 Inheritance ¶\nThe class attribute of an object can have several elements. When a  generic function is called the first inheritance is mainly handled through NextMethod. NextMethod determines the method currently being evaluated, finds the next class from the\nFIXME: something is missing here",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#method-dispatching",
    "href": "Object-oriented-programming.html#method-dispatching",
    "title": "5  Object-oriented programming ¶",
    "section": "5.3 Method dispatching ¶",
    "text": "5.3 Method dispatching ¶\nGeneric functions should consist of a single statement. They should usually be of the form foo &lt;- function(x, ...) UseMethod(\"foo\", x). When UseMethod is called, it determines the appropriate method and then that method is invoked with the same arguments, in the same order as the call to the generic, as if the call had been made directly to the method.\nIn order to determine the correct method the class attribute of the first argument to the generic is obtained and used to find the correct method. The  name of the generic function is combined with the first element of the class attribute into the form, generic.class and a function with that name is sought. If the function is found then it is used. If no such function is found then the second element of the class attribute is used, and so on until all the elements of the class attribute have been exhausted. If no method has been found at that point then the method generic.default is used. If the first argument to the generic function has no class attribute then generic.default is used. Since the introduction of namespaces the methods may not be accessible by their names (i.e. get(\"generic.class\") may fail), but they will be accessible by getS3method(\"generic\",\"class\").\nAny object can have a class attribute. This attribute can have any number of elements. Each of these is a string that defines a class. When a generic function is invoked the class of its first argument is examined.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#usemethod",
    "href": "Object-oriented-programming.html#usemethod",
    "title": "5  Object-oriented programming ¶",
    "section": "5.4 UseMethod ¶",
    "text": "5.4 UseMethod ¶\nUseMethod is a special function and it behaves differently from other function calls. The syntax of a call to it is UseMethod(generic,object), where generic is the name of the generic function, object is the object used to determine which method should be chosen. UseMethod can only be called from the body of a function.\nUseMethod changes the evaluation model in two ways. First, when it is invoked it determines the next method (function) to be called. It then invokes that function using the current evaluation  environment; this process will be described shortly. The second way in which UseMethod changes the evaluation environment is that it does not return control to the calling function. This means, that any statements after a call to UseMethod are guaranteed not to be executed.\nWhen UseMethod is invoked the generic function is the specified value in the call to UseMethod. The object to dispatch on is either the supplied second argument or the first argument to the current function. The class of the argument is determined and the first element of it is combined with the name of the generic to determine the appropriate method. So, if the generic had name foo and the class of the object is \"bar\", then R will search for a method named foo.bar. If no such method exists then the inheritance mechanism described above is used to locate an appropriate method.\nOnce a method has been determined R invokes it in a special way. Rather than creating a new evaluation  environment R uses the environment of the current function call (the call to the generic). Any  assignments or evaluations that were made before the call to UseMethod will be in effect. The arguments that were used in the call to the generic are rematched to the formal arguments of the selected method.\nWhen the method is invoked it is called with arguments that are the same in number and have the same names as in the call to the generic. They are matched to the arguments of the method according to the standard R rules for argument matching. However the object, i.e. the first argument has been evaluated.\nThe call to UseMethod has the effect of placing some special objects in the evaluation frame. They are .Class, .Generic and .Method. These special objects are used to by R to handle the method dispatch and inheritance. .Class is the class of the object, .Generic is the name of the generic function and .Method is the name of the method currently being invoked. If the method was invoked through one of the internal interfaces then there may also be an object called .Group. This will be described in Section Group methods. After the initial call to UseMethod these special variables, not the object itself, control the selection of subsequent methods.\nThe body of the method is then evaluated in the standard fashion. In particular variable look-up in the body follows the rules for the method. So if the method has an associated environment then that is used. In effect we have replaced the call to the generic by a call to the method. [Prior to R 4.4.0 any local  assignments in the frame of the generic would be carried forward into the call to the method; this is no longer the case.] It is important to realize that control will never return to the generic and hence any expressions after a call to UseMethod will never be executed.\nAny arguments to the generic that were evaluated prior to the call to UseMethod remain evaluated.\nIf the first argument to UseMethod is not supplied it is assumed to be the name of the current function. If two arguments are supplied to UseMethod then the first is the name of the method and the second is assumed to be the object that will be dispatched on. It is evaluated so that the required method can be determined. In this case the first argument in the call to the generic is not evaluated and is discarded. There is no way to change the other arguments in the call to the method; these remain as they were in the call to the generic. This is in contrast to NextMethod where the arguments in the call to the next method can be altered.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#nextmethod",
    "href": "Object-oriented-programming.html#nextmethod",
    "title": "5  Object-oriented programming ¶",
    "section": "5.5 NextMethod ¶",
    "text": "5.5 NextMethod ¶\nNextMethod is used to provide a simple inheritance mechanism.\nMethods invoked as a result of a call to NextMethod behave as if they had been invoked from the previous method. The arguments to the inherited method are in the same order and have the same names as the call to the current method. This means that they are the same as for the call to the generic. However, the expressions for the arguments are the names of the corresponding formal arguments of the current method. Thus the arguments will have values that correspond to their value at the time NextMethod was invoked.\nUnevaluated arguments remain unevaluated. Missing arguments remain missing.\nThe syntax for a call to NextMethod is NextMethod(generic, object, ...). If the generic is not supplied the value of .Generic is used. If the object is not supplied the first argument in the call to the current method is used. Values in the ... argument are used to modify the arguments of the next method.\nIt is important to realize that the choice of the next method depends on the current values of .Generic and .Class and not on the object. So changing the object in a call to NextMethod affects the arguments received by the next method but does not affect the choice of the next method.\nMethods can be called directly. If they are then there will be no .Generic, .Class or .Method. In this case the generic argument of NextMethod must be specified. The value of .Class is taken to be the class attribute of the object which is the first argument to the current function. The value of .Method is the name of the current function. These choices for default values ensure that the behaviour of a method doesn’t change depending on whether it is called directly or via a call to a generic.\nAn issue for discussion is the behaviour of the ... argument to NextMethod. The White Book describes the behaviour as follows:\n- named arguments replace the corresponding arguments in the call to the current method. Unnamed arguments go at the start of the argument list.\nWhat I would like to do is:\n-first do the argument matching for NextMethod; -if the object or generic are changed fine -first if a named list element matches an argument (named or not) the list value replaces the argument value. - the first unnamed list element\nValues for lookup: Class: comes first from .Class, second from the first argument to the method and last from the object specified in the call to NextMethod\nGeneric: comes first from .Generic, if nothing then from the first argument to the method and if it’s still missing from the call to NextMethod\nMethod: this should just be the current function name.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#group-methods",
    "href": "Object-oriented-programming.html#group-methods",
    "title": "5  Object-oriented programming ¶",
    "section": "5.6 Group methods ¶",
    "text": "5.6 Group methods ¶\nFor several types of  internal functions R provides a dispatching mechanism for operators. This means that operators such as == or &lt; can have their behaviour modified for members of special classes. The functions and operators have been grouped into three categories and group methods can be written for each of these categories. There is currently no mechanism to add groups. It is possible to write methods specific to any function within a group.\nThe following table lists the functions for the different Groups.\n\nMath’\n\nabs, acos, acosh, asin, asinh, atan, atanh, ceiling, cos, cosh, cospi, cumsum, exp, floor, gamma, lgamma, log, log10, round, signif, sin, sinh, sinpi, tan, tanh, tanpi, trunc\n\nSummary’\n\nall, any, max, min, prod, range, sum\n\nOps’\n\n+, -, *, /, ^, &lt;, &gt;, &lt;=, &gt;=, !=, ==, %%, %/%, &, |, !\n\n\nFor operators in the Ops group a special method is invoked if the two operands taken together suggest a single method. Specifically, if both operands correspond to the same method or if one operand corresponds to a method that takes precedence over that of the other operand. If they do not suggest a single method then the default method is used. Either a group method or a class method dominates if the other operand has no corresponding method. A class method dominates a group method.\nWhen the group is Ops the special variable .Method is a character vector with two elements. The elements of .Method are set to the name of the method if the corresponding argument is a member of the class that was used to determine the method. Otherwise the corresponding element of .Method is set to the zero length string, \"\".",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Object-oriented-programming.html#writing-methods",
    "href": "Object-oriented-programming.html#writing-methods",
    "title": "5  Object-oriented programming ¶",
    "section": "5.7 Writing methods ¶",
    "text": "5.7 Writing methods ¶\nUsers can easily write their own methods and generic functions. A  generic function is simply a function with a call to UseMethod. A method is simply a function that has been invoked via method dispatch. This can be as a result of a call to either UseMethod or NextMethod.\nIt is worth remembering that methods can be called directly. That means that they can be entered without a call to UseMethod having been made and hence the special variables .Generic, .Class and .Method will not have been instantiated. In that case the default rules detailed above will be used to determine these.\nThe most common use of  generic functions is to provide print and summary methods for statistical objects, generally the output of some model fitting process. To do this, each model attaches a class attribute to its output and then provides a special method that takes that output and provides a nice readable version of it. The user then needs only remember that print or summary will provide nice output for the results of any analysis.\nNext: Computing on the language, Previous: Functions, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Object-oriented programming [¶](#object-oriented-programming-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html",
    "href": "Computing-on-the-language.html",
    "title": "6  Computing on the language ¶",
    "section": "",
    "text": "6.1 Direct manipulation of language objects ¶\nNext: System and foreign language interfaces, Previous: Object-oriented programming, Up: R Language Definition   [Contents][Index]\nR belongs to a class of programming languages in which subroutines have the ability to modify or construct other subroutines and evaluate the result as an integral part of the language itself. This is similar to Lisp and Scheme and other languages of the “functional programming” variety, but in contrast to FORTRAN and the ALGOL family. The Lisp family takes this feature to the extreme by the “everything is a list” paradigm in which there is no distinction between programs and data.\nR presents a friendlier interface to programming than Lisp does, at least to someone used to mathematical formulas and C-like control structures, but the engine is really very Lisp-like. R allows direct access to  parsed expressions and functions and allows you to alter and subsequently execute them, or create entirely new functions from scratch.\nThere is a number of standard applications of this facility, such as calculation of analytical derivatives of expressions, or the generation of polynomial functions from a vector of coefficients. However, there are also uses that are much more fundamental to the workings of the interpreted part of R. Some of these are essential to the reuse of functions as components in other functions, as the (admittedly not very pretty) calls to model.frame that are constructed in several modeling and plotting routines. Other uses simply allow elegant interfaces to useful functionality. As an example, consider the curve function, which allows you to draw the graph of a function given as an expression like sin(x) or the facilities for plotting mathematical expressions.\nIn this chapter, we give an introduction to the set of facilities that are available for computing on the language.\nThere are three kinds of language objects that are available for modification, calls, expressions, and functions. At this point, we shall concentrate on the call objects. These are sometimes referred to as “unevaluated expressions”, although this terminology is somewhat confusing. The most direct method of obtaining a call object is to use quote with an expression argument, e.g.,\nThe arguments are not evaluated, the result is simply the parsed argument. The objects e1 and e2 may be evaluated later using eval, or simply manipulated as data. It is perhaps most immediately obvious why the e2 object has mode \"call\", since it involves a call to the plot function with some arguments. However, e1 actually has exactly the same structure as a call to the binary operator + with two arguments, a fact that gets clearly displayed by the following\nThe components of a call object are accessed using a list-like syntax, and may in fact be converted to and from lists using as.list and as.call\nWhen keyword argument matching is used, the keywords can be used as list tags:\nAll the components of the call object have mode \"name\" in the preceding examples. This is true for identifiers in calls, but the components of a call can also be constants—which can be of any type, although the first component had better be a function if the call is to be evaluated successfully—or other call objects, corresponding to subexpressions. Objects of mode  name can be constructed from character strings using as.name, so one might modify the e2 object as follows\nTo illustrate the fact that subexpressions are simply components that are themselves calls, consider\nAll grouping parentheses in input are preserved in parsed expressions. They are represented as a function call with one argument, so that 4 - (2 - 2) becomes \"-\"(4, \"(\" (\"-\"(2, 2))) in prefix notation. In evaluations, the (’ operator just returns its argument.\nThis is a bit unfortunate, but it is not easy to write a  parser/deparser combination that both preserves user input, stores it in minimal form and ensures that parsing a deparsed expression gives the same expression back.\nAs it happens, R’s parser is not perfectly invertible, nor is its deparser, as the following examples show\nDeparsed expressions should, however, evaluate to an equivalent value to the original expression (up to rounding error).\n...internal storage of flow control constructs...note Splus incompatibility...",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#direct-manipulation-of-language-objects",
    "href": "Computing-on-the-language.html#direct-manipulation-of-language-objects",
    "title": "6  Computing on the language ¶",
    "section": "",
    "text": "&gt; e1 &lt;- quote(2 + 2)\n&gt; e2 &lt;- quote(plot(x, y))\n\n&gt; quote(\"+\"(2, 2))\n2 + 2\n\n&gt; e2[[1]]\nplot\n&gt; e2[[2]]\nx\n&gt; e2[[3]]\ny\n\n&gt; e3 &lt;- quote(plot(x = age, y = weight))\n&gt; e3$x\nage\n&gt; e3$y\nweight\n\n&gt; e2[[1]] &lt;- as.name(\"+\")\n&gt; e2\nx + y\n\n&gt; e1[[2]] &lt;- e2\n&gt; e1\nx + y + 2\n\n\n\n&gt; str(quote(c(1,2)))\n language c(1, 2)\n&gt; str(c(1,2))\n num [1:2] 1 2\n&gt; deparse(quote(c(1,2)))\n[1] \"c(1, 2)\"\n&gt; deparse(c(1,2))\n[1] \"c(1, 2)\"\n&gt; quote(\"-\"(2, 2))\n2 - 2\n&gt; quote(2 - 2)\n2 - 2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#substitutions",
    "href": "Computing-on-the-language.html#substitutions",
    "title": "6  Computing on the language ¶",
    "section": "6.2 Substitutions ¶",
    "text": "6.2 Substitutions ¶\nIt is in fact not often that one wants to modify the innards of an expression like in the previous section. More frequently, one wants to simply get at an expression in order to deparse it and use it for labeling plots, for instance. An example of this is seen at the beginning of plot.default: \nxlabel &lt;- if (!missing(x))\n    deparse(substitute(x))\nThis causes the variable or expression given as the x argument to plot to be used for labeling the x-axis later on.\nThe function used to achieve this is substitute which takes the expression x and substitutes the expression that was passed through the formal argument x. Notice that for this to happen, x must carry information about the expression that creates its value. This is related to the  lazy evaluation scheme of R (see Promise objects). A formal argument is really a promise, an object with three slots, one for the expression that defines it, one for the environment in which to evaluate that expression, and one for the value of that expression once evaluated. substitute will recognize a promise variable and substitute the value of its expression slot. If substitute is invoked inside a function, the local variables of the function are also subject to substitution.\nThe argument to substitute does not have to be a simple identifier, it can be an expression involving several variables and substitution will occur for each of these. Also, substitute has an additional argument which can be an environment or a list in which the variables are looked up. For example:\n&gt; substitute(a + b, list(a = 1, b = quote(x)))\n1 + x\nNotice that quoting was necessary to substitute the x. This kind of construction comes in handy in connection with the facilities for putting math expression in graphs, as the following case shows\n&gt; plot(0)\n&gt; for (i in 1:4)\n+   text(1, 0.2 * i,\n+        substitute(x[ix] == y, list(ix = i, y = pnorm(i))))\nIt is important to realize that the substitutions are purely lexical; there is no checking that the resulting call objects make sense if they are evaluated. substitute(x &lt;- x + 1, list(x = 2)) will happily return 2 &lt;- 2 + 1. However, some parts of R make up their own rules for what makes sense and what does not and might actually have a use for such ill-formed expressions. For example, using the “math in graphs” feature often involves constructions that are syntactically correct, but which would be meaningless to evaluate, like {}&gt;=40*\" years\"’.\nSubstitute will not evaluate its first argument. This leads to the puzzle of how to do substitutions on an object that is contained in a variable. The solution is to use substitute once more, like this\n&gt; expr &lt;- quote(x + y)\n&gt; substitute(substitute(e, list(x = 3)), list(e = expr))\nsubstitute(x + y, list(x = 3))\n&gt; eval(substitute(substitute(e, list(x = 3)), list(e = expr)))\n3 + y\nThe exact rules for substitutions are as follows: Each  symbol in the  parse tree for the first is matched against the second argument, which can be a tagged list or an environment frame. If it is a simple local object, its value is inserted, except if matching against the global environment. If it is a promise (usually a function argument), the promise expression is substituted. If the symbol is not matched, it is left untouched. The special exception for substituting at the top level is admittedly peculiar. It has been inherited from S and the rationale is most likely that there is no control over which variables might be bound at that level so that it would be better to just make substitute act as quote.\nThe rule of promise substitution is slightly different from that of S if the local variable is modified before substitute is used. R will then use the new value of the variable, whereas S will unconditionally use the argument expression—unless it was a constant, which has the curious consequence that f((1)) may be very different from f(1) in S. The R rule is considerably cleaner, although it does have consequences in connection with  lazy evaluation that comes as a surprise to some. Consider\nlogplot &lt;- function(y, ylab = deparse(substitute(y))) {\n    y &lt;- log(y)\n    plot(y, ylab = ylab)\n}\nThis looks straightforward, but one will discover that the y label becomes an ugly c(...) expression. It happens because the rules of lazy evaluation cause the evaluation of the ylab expression to happen after y has been modified. The solution is to force ylab to be evaluated first, i.e.,\nlogplot &lt;- function(y, ylab = deparse(substitute(y))) {\n    ylab\n    y &lt;- log(y)\n    plot(y, ylab = ylab)\n}\nNotice that one should not use eval(ylab) in this situation. If ylab is a language or expression object, then that would cause the object to be evaluated as well, which would not at all be desirable if a math expression like quote(log[e](y)) was being passed.\nA variant on substitute is bquote, which is used to replace some subexpressions with their values. The example from above\n&gt; plot(0)\n&gt; for (i in 1:4)\n+   text(1, 0.2 * i,\n+        substitute(x[ix] == y, list(ix = i, y = pnorm(i))))\ncould be written more compactly as\nplot(0)\nfor(i in 1:4)\n   text(1, 0.2*i, bquote( x[.(i)] == .(pnorm(i)) ))\nThe expression is quoted except for the contents of .() subexpressions, which are replaced with their values. There is an optional argument to compute the values in a different environment. The syntax for bquote is borrowed from the LISP backquote macro.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#more-on-evaluation",
    "href": "Computing-on-the-language.html#more-on-evaluation",
    "title": "6  Computing on the language ¶",
    "section": "6.3 More on evaluation ¶",
    "text": "6.3 More on evaluation ¶\nThe eval function was introduced earlier in this chapter as a means of evaluating call objects. However, this is not the full story. It is also possible to specify the  environment in which the evaluation is to take place. By default this is the evaluation frame from which eval is called, but quite frequently it needs to be set to something else.\nVery often, the relevant evaluation frame is that of the parent of the current frame (cf. ???). In particular, when the object to evaluate is the result of a substitute operation of the function arguments, it will contain variables that make sense to the caller only (notice that there is no reason to expect that the variables of the caller are in the  lexical scope of the callee). Since evaluation in the parent frame occurs frequently, an eval.parent function exists as a shorthand for eval(expr, sys.frame(sys.parent())).\nAnother case that occurs frequently is evaluation in a list or a data frame. For instance, this happens in connection with the model.frame function when a data argument is given. Generally, the terms of the model formula need to be evaluated in data, but they may occasionally also contain references to items in the caller of model.frame. This is sometimes useful in connection with simulation studies. So for this purpose one needs not only to evaluate an expression in a list, but also to specify an enclosure into which the search continues if the variable is not in the list. Hence, the call has the form\neval(expr, data, sys.frame(sys.parent()))\nNotice that evaluation in a given environment may actually change that environment, most obviously in cases involving the  assignment operator, such as\neval(quote(total &lt;- 0), environment(robert$balance)) # rob Rob\nThis is also true when evaluating in lists, but the original list does not change because one is really working on a copy.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#evaluation-of-expression-objects",
    "href": "Computing-on-the-language.html#evaluation-of-expression-objects",
    "title": "6  Computing on the language ¶",
    "section": "6.4 Evaluation of expression objects ¶",
    "text": "6.4 Evaluation of expression objects ¶\nObjects of mode \"expression\" are defined in Expression objects. They are very similar to lists of call objects.\n&gt; ex &lt;- expression(2 + 2, 3 + 4)\n&gt; ex[[1]]\n2 + 2\n&gt; ex[[2]]\n3 + 4\n&gt; eval(ex)\n[1] 7\nNotice that evaluating an expression object evaluates each call in turn, but the final value is that of the last call. In this respect it behaves almost identically to the compound language object quote({2 + 2; 3 + 4}). However, there is a subtle difference: Call objects are indistinguishable from subexpressions in a parse tree. This means that they are automatically evaluated in the same way a subexpression would be. Expression objects can be recognized during evaluation and in a sense retain their quotedness. The evaluator will not evaluate an expression object recursively, only when it is passed directly to eval function as above. The difference can be seen like this:\n&gt; eval(substitute(mode(x), list(x = quote(2 + 2))))\n[1] \"numeric\"\n&gt; eval(substitute(mode(x), list(x = expression(2 + 2))))\n[1] \"expression\"\nThe deparser represents an expression object by the call that creates it. This is similar to the way it handles numerical vectors and several other objects that do not have a specific external representation. However, it does lead to the following bit of confusion:\n&gt; e &lt;- quote(expression(2 + 2))\n&gt; e\nexpression(2 + 2)\n&gt; mode(e)\n[1] \"call\"\n&gt; ee &lt;- expression(2 + 2)\n&gt; ee\nexpression(2 + 2)\n&gt; mode(ee)\n[1] \"expression\"\nI.e., e and ee look identical when printed, but one is a call that generates an expression object and the other is the object itself.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#manipulation-of-function-calls",
    "href": "Computing-on-the-language.html#manipulation-of-function-calls",
    "title": "6  Computing on the language ¶",
    "section": "6.5 Manipulation of function calls ¶",
    "text": "6.5 Manipulation of function calls ¶\nIt is possible for a  function to find out how it has been called by looking at the result of sys.call as in the following example of a function that simply returns its own call:\n&gt; f &lt;- function(x, y, ...) sys.call()\n&gt; f(y = 1, 2, z = 3, 4)\nf(y = 1, 2, z = 3, 4)\nHowever, this is not really useful except for debugging because it requires the function to keep track of argument matching in order to interpret the call. For instance, it must be able to see that the 2nd actual argument gets matched to the first formal one (x in the above example).\nMore often one requires the call with all actual arguments bound to the corresponding formals. To this end, the function match.call is used. Here’s a variant of the preceding example, a function that returns its own call with arguments matched\n&gt; f &lt;- function(x, y, ...) match.call()\n&gt; f(y = 1, 2, z = 3, 4)\nf(x = 2, y = 1, z = 3, 4)\nNotice that the second argument now gets matched to x and appears in the corresponding position in the result.\nThe primary use of this technique is to call another function with the same arguments, possibly deleting some and adding others. A typical application is seen at the start of the lm function:\n    mf &lt;- cl &lt;- match.call()\n    mf$singular.ok &lt;- mf$model &lt;- mf$method &lt;- NULL\n    mf$x &lt;- mf$y &lt;- mf$qr &lt;- mf$contrasts &lt;- NULL\n    mf$drop.unused.levels &lt;- TRUE\n    mf[[1]] &lt;- as.name(\"model.frame\")\n    mf &lt;- eval(mf, sys.frame(sys.parent()))\nNotice that the resulting call is  evaluated in the parent frame, in which one can be certain that the involved expressions make sense. The call can be treated as a list object where the first element is the name of the function and the remaining elements are the actual argument expressions, with the corresponding formal argument names as tags. Thus, the technique to eliminate undesired arguments is to assign NULL, as seen in lines 2 and 3, and to add an argument one uses tagged list  assignment (here to pass drop.unused.levels = TRUE) as in line 4. To change the name of the function called, assign to the first element of the list and make sure that the value is a name, either using the as.name(\"model.frame\") construction here or quote(model.frame).\nThe match.call function has an expand.dots argument, a switch which if set to FALSE lets all ... arguments be collected as a single argument with the tag ....\n&gt; f &lt;- function(x, y, ...) match.call(expand.dots = FALSE)\n&gt; f(y = 1, 2, z = 3, 4)\nf(x = 2, y = 1, ... = list(z = 3, 4))\nThe ... argument is a list (a pairlist to be precise), not a call to list like it is in S:\n&gt; e1 &lt;- f(y = 1, 2, z = 3, 4)$...\n&gt; e1\n$z\n[1] 3\n\n[[2]]\n[1] 4\nOne reason for using this form of match.call is simply to get rid of any ... arguments in order not to be passing unspecified arguments on to functions that may not know them. Here’s an example paraphrased from plot.formula:\nm &lt;- match.call(expand.dots = FALSE)\nm$... &lt;- NULL\nm[[1]] &lt;- \"model.frame\"\nA more elaborate application is in update.default where a set of optional extra arguments can add to, replace, or cancel those of the original call:\nextras &lt;- match.call(expand.dots = FALSE)$...\nif (length(extras) &gt; 0) {\n    existing &lt;- !is.na(match(names(extras), names(call)))\n    for (a in names(extras)[existing]) call[[a]] &lt;- extras[[a]]\n    if (any(!existing)) {\n        call &lt;- c(as.list(call), extras[!existing])\n        call &lt;- as.call(call)\n    }\n}\nNotice that care is taken to modify existing arguments individually in case extras[[a]] == NULL. Concatenation does not work on call objects without the coercion as shown; this is arguably a bug.\nTwo further functions exist for the construction of function calls, namely call and do.call.\nThe function call allows creation of a call object from the function name and the list of arguments\n&gt; x &lt;- 10.5\n&gt; call(\"round\", x)\nround(10.5)\nAs seen, the value of x rather than the  symbol is inserted in the call, so it is distinctly different from round(x). The form is used rather rarely, but is occasionally useful where the name of a function is available as a character variable.\nThe function do.call is related, but evaluates the call immediately and takes the arguments from an object of mode \"list\" containing all the arguments. A natural use of this is when one wants to apply a function like cbind to all elements of a list or data frame. \nis.na.data.frame &lt;- function (x) {\n    y &lt;- do.call(cbind, lapply(x, is.na))\n    rownames(y) &lt;- row.names(x)\n    y\n}\nOther uses include variations over constructions like do.call(\"f\", list(...)). However, one should be aware that this involves evaluation of the arguments before the actual function call, which may defeat aspects of lazy evaluation and argument substitution in the function itself. A similar remark applies to the call function.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Computing-on-the-language.html#manipulation-of-functions",
    "href": "Computing-on-the-language.html#manipulation-of-functions",
    "title": "6  Computing on the language ¶",
    "section": "6.6 Manipulation of functions ¶",
    "text": "6.6 Manipulation of functions ¶\nIt is often useful to be able to manipulate the components of a  function or closure. R provides a set of interface functions for this purpose.\n: Returns the expression that is the body of the function.\n: Returns a list of the formal arguments to the function. This is a pairlist.\n: \nReturns the environment associated with the function.\n: This sets the body of the function to the supplied expression.\n: Sets the formal arguments of the function to the supplied list.\n: Sets the environment of the function to the specified environment.\nIt is also possible to alter the bindings of different variables in the environment of the function, using code along the lines of evalq(x &lt;- 5, environment(f)).\nIt is also possible to convert a  function to a list using as.list. The result is the concatenation of the list of formal arguments with the function body. Conversely such a list can be converted to a function using as.function. This functionality is mainly included for S compatibility. Notice that environment information is lost when as.list is used, whereas as.function has an argument that allows the environment to be set.\nNext: System and foreign language interfaces, Previous: Object-oriented programming, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Computing on the language [¶](#computing-on-the-language-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "System-and-foreign-language-interfaces.html",
    "href": "System-and-foreign-language-interfaces.html",
    "title": "7  System and foreign language interfaces ¶",
    "section": "",
    "text": "7.1 Operating system access ¶\nNext: Exception handling, Previous: Computing on the language, Up: R Language Definition   [Contents][Index]\nAccess to the operating system shell is via the R function system.  The details will differ by platform (see the on-line help), and about all that can safely be assumed is that the first argument will be a string command that will be passed for execution (not necessarily by a shell) and the second argument will be internal which if true will collect the output of the command into an R character vector.\nThe functions system.time  and proc.time  are available for timing (although the information available may be limited on non-Unix-like platforms).\nInformation from the operating system  environment can be accessed and manipulated with\nA uniform set of file access functions is provided on all platforms:\nThere are also functions for manipulating file names and paths in a platform-independent way.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System and foreign language interfaces [¶](#system-and-foreign-language-interfaces-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "System-and-foreign-language-interfaces.html#operating-system-access",
    "href": "System-and-foreign-language-interfaces.html#operating-system-access",
    "title": "7  System and foreign language interfaces ¶",
    "section": "",
    "text": "Sys.getenv\nOS environment variables \n\n\nSys.putenv \n\n\n\nSys.getlocale\nSystem locale \n\n\nSys.putlocale \n\n\n\nSys.localeconv \n\n\n\nSys.time\nCurrent time \n\n\nSys.timezone\nTime zone \n\n\n\n\n\n\n\n\n\nfile.access\nAscertain File Accessibility \n\n\nfile.append\nConcatenate files \n\n\nfile.choose\nPrompt user for file name \n\n\nfile.copy\nCopy files \n\n\nfile.create\nCreate or truncate a files \n\n\nfile.exists\nTest for existence \n\n\nfile.info\nMiscellaneous file information \n\n\nfile.remove\nremove files \n\n\nfile.rename\nrename files \n\n\nfile.show\nDisplay a text file \n\n\nunlink\nRemove files or directories. \n\n\n\n\n\n\n\n\n\nbasename\nFile name without directory \n\n\ndirname\nDirectory name \n\n\nfile.path\nConstruct path to file \n\n\npath.expand\nExpand ~ in Unix path",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System and foreign language interfaces [¶](#system-and-foreign-language-interfaces-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "System-and-foreign-language-interfaces.html#foreign-language-interfaces",
    "href": "System-and-foreign-language-interfaces.html#foreign-language-interfaces",
    "title": "7  System and foreign language interfaces ¶",
    "section": "7.2 Foreign language interfaces ¶",
    "text": "7.2 Foreign language interfaces ¶\n  \nSee System and foreign language interfaces in Writing R Extensions for the details of adding functionality to R via compiled code.\nFunctions .C and .Fortran provide a standard interface to compiled code that has been linked into R, either at build time or via dyn.load. They are primarily intended for compiled C and FORTRAN code respectively, but the .C function can be used with other languages which can generate C interfaces, for example C++.\nFunctions .Call and .External provide interfaces which allow compiled code (primarily compiled C code) to manipulate R objects.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System and foreign language interfaces [¶](#system-and-foreign-language-interfaces-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "System-and-foreign-language-interfaces.html#internal-and-.primitive",
    "href": "System-and-foreign-language-interfaces.html#internal-and-.primitive",
    "title": "7  System and foreign language interfaces ¶",
    "section": "7.3 .Internal and .Primitive ¶",
    "text": "7.3 .Internal and .Primitive ¶\n \nThe .Internal and .Primitive interfaces are used to call C code compiled into R at build time. See .Internal vs .Primitive in R Internals.\nNext: Exception handling, Previous: Computing on the language, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>System and foreign language interfaces [¶](#system-and-foreign-language-interfaces-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Exception-handling.html",
    "href": "Exception-handling.html",
    "title": "8  Exception handling ¶",
    "section": "",
    "text": "8.1 stop ¶\nNext: Debugging, Previous: System and foreign language interfaces, Up: R Language Definition   [Contents][Index]\nThe exception handling facilities in R are provided through two mechanisms. Functions such as stop or warning can be called directly or options such as \"warn\" can be used to control the handling of problems.\nA call to stop halts the evaluation of the current expression, prints the message argument and returns execution to top-level.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exception handling [¶](#exception-handling-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Exception-handling.html#warning",
    "href": "Exception-handling.html#warning",
    "title": "8  Exception handling ¶",
    "section": "8.2 warning ¶",
    "text": "8.2 warning ¶\nThe function warning takes a single argument that is a character string. The behaviour of a call to warning depends on the value of the option \"warn\". If \"warn\" is negative warnings are ignored. If it is zero, they are stored and printed after the top-level function has completed. If it is one, they are printed as they occur and if it is 2 (or larger) warnings are turned into errors.\nIf \"warn\" is zero (the default), a variable last.warning is created and the messages associated with each call to warning are stored, sequentially, in this vector. If there are fewer than 10 warnings they are printed after the function has finished evaluating. If there are more than 10 then a message indicating how many warnings occurred is printed. In either case last.warning contains the vector of messages, and warnings provides a way to access and print it.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exception handling [¶](#exception-handling-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Exception-handling.html#on.exit",
    "href": "Exception-handling.html#on.exit",
    "title": "8  Exception handling ¶",
    "section": "8.3 on.exit ¶",
    "text": "8.3 on.exit ¶\nA function can insert a call to on.exit at any point in the body of a function. The effect of a call to on.exit is to store the value of the body so that it will be executed when the function exits. This allows the function to change some system parameters and to ensure that they are reset to appropriate values when the function is finished. The on.exit is guaranteed to be executed when the function exits either directly or as the result of a warning.\nAn error in the evaluation of the on.exit code causes an immediate jump to top-level without further processing of the on.exit code.\non.exit takes a single argument which is an expression to be evaluated when the function is exited.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exception handling [¶](#exception-handling-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Exception-handling.html#error-options",
    "href": "Exception-handling.html#error-options",
    "title": "8  Exception handling ¶",
    "section": "8.4 Error options ¶",
    "text": "8.4 Error options ¶\nThere are a number of options variables that can be used to control how R handles errors and warnings. They are listed in the table below.\n\nwarn’\n\nControls the printing of warnings.\n\nwarning.expression’\n\nSets an expression that is to be evaluated when a warning occurs. The normal printing of warnings is suppressed if this option is set.\n\nerror’\n\nInstalls an expression that will be evaluated when an error occurs. The normal printing of error messages and warning messages precedes the evaluation of the expression.\n\n\nExpressions installed by options(\"error\") are evaluated before calls to on.exit are carried out.\nOne can use options(error = expression(q(\"yes\"))) to get R to quit when an error has been signalled. In this case an error will cause R to shut down and the global environment will be saved.\nNext: Debugging, Previous: System and foreign language interfaces, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Exception handling [¶](#exception-handling-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Debugging.html",
    "href": "Debugging.html",
    "title": "9  Debugging ¶",
    "section": "",
    "text": "9.1 browser ¶\nNext: Parser, Previous: Exception handling, Up: R Language Definition   [Contents][Index]\nDebugging code has always been a bit of an art. R provides several tools that help users find problems in their code. These tools halt execution at particular points in the code and the current state of the computation can be inspected.\nMost debugging takes place either through calls to browser or debug. Both of these functions rely on the same internal mechanism and both provide the user with a special prompt. Any command can be typed at the prompt. The evaluation  environment for the command is the currently active environment. This allows you to examine the current state of any variables etc.\nThere are five special commands that R interprets differently. They are,\nc‘\ncont’\n: Continue the execution.\nIf there is a local variable with the same name as one of the special commands listed above then its value can be accessed by using get. A call to get with the name in quotes will retrieve the value in the current  environment.\nThe debugger provides access only to interpreted expressions. If a function calls a foreign language (such as C) then no access to the statements in that language is provided. Execution will halt on the next statement that is evaluated in R. A symbolic debugger such as gdb can be used to debug compiled code.\nA call to the function browser causes R to halt execution at that point and to provide the user with a special prompt. Arguments to browser are ignored.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging [¶](#debugging-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Debugging.html#browser",
    "href": "Debugging.html#browser",
    "title": "9  Debugging ¶",
    "section": "",
    "text": "&gt; foo &lt;- function(s) {\n+ c &lt;- 3\n+ browser()\n+ }\n&gt; foo(4)\nCalled from: foo(4)\nBrowse[1]&gt; s\n[1] 4\nBrowse[1]&gt; get(\"c\")\n[1] 3\nBrowse[1]&gt;",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging [¶](#debugging-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Debugging.html#debugundebug",
    "href": "Debugging.html#debugundebug",
    "title": "9  Debugging ¶",
    "section": "9.2 debug/undebug ¶",
    "text": "9.2 debug/undebug ¶\nThe debugger can be invoked on any function by using the command debug(fun). Subsequently, each time that function is evaluated the debugger is invoked. The debugger allows you to control the evaluation of the statements in the body of the function. Before each statement is executed the statement is printed out and a special prompt provided. Any command can be given, those in the table above have special meaning.\nDebugging is turned off by a call to undebug with the function as an argument.\n&gt; debug(mean.default)\n&gt; mean(1:10)\ndebugging in: mean.default(1:10)\ndebug: {\n    if (na.rm)\n        x &lt;- x[!is.na(x)]\n    trim &lt;- trim[1]\n    n &lt;- length(c(x, recursive = TRUE))\n    if (trim &gt; 0) {\n        if (trim &gt;= 0.5)\n            return(median(x, na.rm = FALSE))\n        lo &lt;- floor(n * trim) + 1\n        hi &lt;- n + 1 - lo\n        x &lt;- sort(x, partial = unique(c(lo, hi)))[lo:hi]\n        n &lt;- hi - lo + 1\n    }\n    sum(x)/n\n}\nBrowse[1]&gt;\ndebug: if (na.rm) x &lt;- x[!is.na(x)]\nBrowse[1]&gt;\ndebug: trim &lt;- trim[1]\nBrowse[1]&gt;\ndebug: n &lt;- length(c(x, recursive = TRUE))\nBrowse[1]&gt; c\nexiting from: mean.default(1:10)\n[1] 5.5",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging [¶](#debugging-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Debugging.html#traceuntrace",
    "href": "Debugging.html#traceuntrace",
    "title": "9  Debugging ¶",
    "section": "9.3 trace/untrace ¶",
    "text": "9.3 trace/untrace ¶\nAnother way of monitoring the behaviour of R is through the trace mechanism. trace is called with a single argument that is the name of the function you want to trace. The name does not need to be quoted but for some functions you will need to quote the name in order to avoid a syntax error.\nWhen trace has been invoked on a function then every time that function is evaluated the call to it is printed out. This mechanism is removed by calling untrace with the function as an argument.\n&gt; trace(\"[&lt;-\")\n&gt; x &lt;- 1:10\n&gt; x[3] &lt;- 4\ntrace: \"[&lt;-\"(*tmp*, 3, value = 4)",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging [¶](#debugging-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Debugging.html#traceback",
    "href": "Debugging.html#traceback",
    "title": "9  Debugging ¶",
    "section": "9.4 traceback ¶",
    "text": "9.4 traceback ¶\nWhen an error has caused a jump to top-level a special variable called .Traceback is placed into the base environment. .Traceback is a character vector with one entry for each function call that was active at the time the error occurred. An examination of .Traceback can be carried out by a call to traceback.\nNext: Parser, Previous: Exception handling, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Debugging [¶](#debugging-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html",
    "href": "Parser.html",
    "title": "10  Parser ¶",
    "section": "",
    "text": "10.1 The parsing process ¶\nNext: Function and Variable Index, Previous: Debugging, Up: R Language Definition   [Contents][Index]\nThe parser is what converts the textual representation of R code into an internal form which may then be passed to the R evaluator which causes the specified instructions to be carried out. The internal form is itself an R object and can be saved and otherwise manipulated within the R system.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html#the-parsing-process",
    "href": "Parser.html#the-parsing-process",
    "title": "10  Parser ¶",
    "section": "",
    "text": "10.1.1 Modes of parsing ¶\nParsing in R occurs in three different variants:\n\nThe read-eval-print loop\nParsing of text files\nParsing of character strings\n\nThe read-eval-print loop forms the basic command line interface to R. Textual input is read until a complete R expression is available. Expressions may be split over several input lines. The primary prompt (by default &gt;‘) indicates that the parser is ready for a new expression, and a continuation prompt (by default +’) indicates that the parser expects the remainder of an incomplete expression. The expression is converted to internal form during input and the parsed expression is passed to the evaluator and the result is printed (unless specifically made invisible). If the parser finds itself in a state which is incompatible with the language syntax, a “Syntax Error” is flagged and the parser resets itself and resumes input at the beginning of the next input line.\nText files can be parsed using the parse function. In particular, this is done during execution of the source function, which allows commands to be stored in an external file and executed as if they had been typed at the keyboard. Note, though, that the entire file is parsed and syntax checked before any evaluation takes place.\nCharacter strings, or vectors thereof, can be parsed using the text= argument to parse. The strings are treated exactly as if they were the lines of an input file.\n\n\n10.1.2 Internal representation ¶\nParsed expressions are stored in an R object containing the parse tree. A fuller description of such objects can be found in Language objects and Expression objects. Briefly, every elementary R expression is stored in  function call form, as a list with the first element containing the function name and the remainder containing the arguments, which may in turn be further R expressions. The list elements can be named, corresponding to tagged matching of formal and actual arguments. Note that all R syntax elements are treated in this way, e.g. the assignment x &lt;- 1 is encoded as \"&lt;-\"(x, 1).\n\n\n10.1.3 Deparsing ¶\nAny R object can be converted to an R expression using deparse. This is frequently used in connection with output of results, e.g. for labeling plots. Notice that only objects of mode \"expression\" can be expected to be unchanged by reparsing the output of deparsing. For instance, the numeric vector 1:5 will deparse as \"c(1, 2, 3, 4, 5)\", which will reparse as a call to the function c. As far as possible, evaluating the deparsed and reparsed expression gives the same result as evaluating the original, but there are a couple of awkward exceptions, mostly involving expressions that weren’t generated from a textual representation in the first place.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html#comments",
    "href": "Parser.html#comments",
    "title": "10  Parser ¶",
    "section": "10.2 Comments ¶",
    "text": "10.2 Comments ¶\nComments in R are ignored by the parser. Any text from a  # character to the end of the line is taken to be a comment, unless the # character is inside a quoted string. For example,\n&gt; x &lt;- 1  # This is a comment...\n&gt; y &lt;- \"  #... but this is not.\"",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html#tokens",
    "href": "Parser.html#tokens",
    "title": "10  Parser ¶",
    "section": "10.3 Tokens ¶",
    "text": "10.3 Tokens ¶\nTokens are the elementary building blocks of a programming language. They are recognised during lexical analysis which (conceptually, at least) takes place prior to the syntactic analysis performed by the parser itself.\n\n10.3.1 Constants ¶\nThere are five types of constants: integer, logical, numeric, complex and string.\nIn addition, there is the special constant NULL. Also, the numeric Inf, and NaN, the logical NA, and NA_character_, NA_integer_, NA_real_, and NA_complex_ deserve mentioning; for the latter, see NA handling.\nNULL is used to indicate the empty object. NA is used for absent (“Not Available”) data values. Inf denotes infinity and NaN is not-a-number in the IEEE floating point calculus (results of the operations respectively 1/0 and 0/0, for instance).\nLogical constants are either TRUE, FALSE or NA.\nNumeric constants follow a similar syntax to that of the C language. They consist of an integer part consisting of zero or more digits, followed optionally by .’ and a fractional part of zero or more digits optionally followed by an exponent part consisting of an E’ or an e’, an optional sign and a string of one or more digits. Either the fractional or the decimal part can be empty, but not both at once.\nValid numeric constants: 1 10 0.1 .2 1e-7 1.2e+7\nNumeric constants can also be hexadecimal, starting with 0x’ or 0x’ followed by zero or more digits, a-f’ or A-F‘. Hexadecimal floating point constants are supported using C99 syntax, e.g. 0x1.1p1’.\nThere is now a separate class of integer constants. They are created by using the qualifier L at the end of the number. For example, 123L gives an integer value rather than a numeric value. The suffix L can be used to qualify any non-complex number with the intent of creating an integer. So it can be used with numbers given by hexadecimal or scientific notation. However, if the value is not a valid integer, a warning is emitted and the numeric value created. The following shows examples of valid integer constants, values which will generate a warning and give numeric constants and syntax errors.\nValid integer constants:  1L, 0x10L, 1000000L, 1e6L\nValid numeric constants:  1.1L, 1e-3L, 0x1.1p-2\nSyntax error:  12iL 0x1.1\nA warning is emitted for decimal values that contain an unnecessary decimal point, e.g. 1.L. It is an error to have a decimal point in a hexadecimal constant without the binary exponent.\nNote also that a preceding sign (+ or -) is treated as a unary operator, not as part of the constant.\nUp-to-date information on the currently accepted formats can be found by ?NumericConstants.\nComplex constants have the form of a decimal numeric constant followed by i’. Notice that only purely imaginary numbers are actual constants, other complex numbers are parsed a unary or binary operations on numeric and imaginary numbers.\nValid complex constants: 2i 4.1i 1e-2i\nString constants are delimited by a pair of single ({.sample .samp}‘) or double (\"’) quotes and can contain all other printable characters. Quotes and other special characters within strings are specified using escape sequences:\n\n\\\n\nsingle quote\n\n\\\"\n\ndouble quote\n\n\\n\n\nnewline (aka ‘line feed’, LF)\n\n\\r\n\ncarriage return (CR)\n\n\\t\n\ntab character\n\n\\b\n\nbackspace\n\n\\a\n\nbell\n\n\\f\n\nform feed\n\n\\v\n\nvertical tab\n\n\\\\\n\nbackslash itself\n\n\\nnn\n\ncharacter with given octal code – sequences of one, two or three digits in the range 0 ... 7 are accepted.\n\n\\xnn\n\ncharacter with given hex code – sequences of one or two hex digits (with entries 0 ... 9 A ... F a ... f).\n\n\\unnnn\\u{nnnn}\n\n(where multibyte locales are supported, otherwise an error). Unicode character with given hex code – sequences of up to four hex digits. The character needs to be valid in the current locale.\n\n\\Unnnnnnnn\\U{nnnnnnnn}\n\n(where multibyte locales are supported, otherwise an error). Unicode character with given hex code – sequences of up to eight hex digits.\n\n\nA single quote may also be embedded directly in a double-quote delimited string and vice versa.\nA NUL (\\0) is not allowed in a character string, so using \\0 in a string constant terminates the constant (usually with a warning): further characters up to the closing quote are scanned but ignored.\n\n\n10.3.2 Identifiers ¶\nIdentifiers consist of a sequence of letters, digits, the period (.’) and the underscore. They must not start with a digit or an underscore, or with a period followed by a digit.\nThe definition of a letter depends on the current locale: the precise set of characters allowed is given by the C expression (isalnum(c) || c == '.' || c == '_') and will include accented letters in many Western European locales.\nNotice that identifiers starting with a period are not by default listed by the ls function and that ... and ..1, ..2, etc. are special.\nNotice also that objects can have names that are not identifiers. These are generally accessed via get and assign, although they can also be represented by text strings in some limited circumstances when there is no ambiguity (e.g. \"x\" &lt;- 1). As get and assign are not restricted to names that are identifiers they do not recognise subscripting operators or replacement functions. The following pairs are not equivalent  \n\n\n\n\nx$a&lt;-1\nassign(\"x$a\",1)\n\n\nx[[1]]\nget(\"x[[1]]\")\n\n\nnames(x)&lt;-nm\nassign(\"names(x)\",nm)\n\n\n\n\n\n\n10.3.3 Reserved words ¶\nThe following identifiers have a special meaning and cannot be used for object names\nif else repeat while function for in next break\nTRUE FALSE NULL Inf NaN\nNA NA_integer_ NA_real_ NA_complex_ NA_character_\n... ..1 ..2 etc.\n\n\n10.3.4 Special operators ¶\nR allows user-defined infix operators. These have the form of a string of characters delimited by the %’ character. The string can contain any printable character except %’. The escape sequences for strings do not apply here.\nNote that the following operators are predefined:\n%% %*% %/% %in% %o% %x% %||%\n\n\n10.3.5 Separators ¶\nAlthough not strictly tokens, stretches of whitespace characters (spaces, tabs and form feeds, on Windows and UTF-8 locales other Unicode whitespace characters5) serve to delimit tokens in case of ambiguity, (compare x&lt;-5 and x &lt; -5).\nNewlines have a function which is a combination of token separator and expression terminator. If an expression can terminate at the end of the line the parser will assume it does so, otherwise the newline is treated as whitespace. Semicolons (;’) may be used to separate elementary  expressions on the same line.\nSpecial rules apply to the else keyword: inside a compound expression, a newline before else is discarded, whereas at the outermost level, the newline terminates the if construction and a subsequent else causes a syntax error. This somewhat anomalous behaviour occurs because R should be usable in interactive mode and then it must decide whether the input expression is complete, incomplete, or invalid as soon as the user presses RET.\nThe comma (,’) is used to separate function arguments and multiple indices.\n\n\n10.3.6 Operator tokens ¶\nR uses the following operator tokens\n\n\n\n\n+ - * / %% %/% ^\narithmetic\n\n\n&gt; &gt;= &lt; &lt;= == !=\nrelational\n\n\n! & |\nlogical\n\n\n~\nmodel formulae\n\n\n-&gt; &lt;-\nassignment\n\n\n$\nlist indexing\n\n\n:\nsequence\n\n\n\n\n(Several of the operators have different meaning inside model formulas)\n\n\n10.3.7 Grouping ¶\nOrdinary parentheses—(’ and )’—are used for explicit grouping within expressions and to delimit the argument lists for function definitions and function calls.\nBraces—{’ and }’—delimit blocks of expressions in function definitions, conditional expressions, and iterative constructs.\n\n\n10.3.8 Indexing tokens ¶\nIndexing of arrays and vectors is performed using the single and double brackets, []’ and [[]]‘. Also, indexing tagged lists may be done using the $’ operator.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html#expressions",
    "href": "Parser.html#expressions",
    "title": "10  Parser ¶",
    "section": "10.4 Expressions ¶",
    "text": "10.4 Expressions ¶\nAn R program consists of a sequence of R expressions. An expression can be a simple expression consisting of only a constant or an identifier, or it can be a compound expression constructed from other parts (which may themselves be expressions).\nThe following sections detail the various syntactical constructs that are available.\n\n10.4.1 Function calls ¶\nA function call takes the form of a function reference followed by a comma-separated list of arguments within a set of parentheses.\nfunction_reference ( arg1, arg2, ...... , argn )\nThe function reference can be either\n\nan identifier (the name of the function)\na text string (ditto, but handy if the function has a name which is not a valid identifier)\nan expression (which should evaluate to a function object)\n\nEach argument can be tagged (tag=expr), or just be a simple expression. It can also be empty or it can be one of the special tokens ..., ..2, etc.\nA tag can be an identifier or a text string.\nExamples:\nf(x)\ng(tag = value, , 5)\n\"odd name\"(\"strange tag\" = 5, y)\n(function(x) x^2)(5)\n\n\n10.4.2 Infix and prefix operators ¶\nThe order of precedence (highest first) of the operators is\n::\n$ @\n^\n- +                (unary)\n:\n%xyz% |&gt;\n* /\n+ -                (binary)\n&gt; &gt;= &lt; &lt;= == !=\n!\n& &&\n| ||\n~                  (unary and binary)\n-&gt; -&gt;&gt;\n&lt;- &lt;&lt;-\n=                  (as assignment)\nNote that : precedes binary +/-, but not ^. Hence, 1:3-1 is 0 1 2, but 1:2^3 is 1:8.\nThe exponentiation operator ^’ and the  left assignment plus minus operators &lt;- - = &lt;&lt;-’ group right to left, all other operators group left to right. That is, 2 ^ 2 ^ 3 is 2 ^ 8, not 4 ^ 3, whereas 1 - 1 - 1 is -1, not 1.\nNotice that the operators %% and %/% for integer remainder and divide have higher precedence than multiply and divide.\nAlthough it is not strictly an operator, it also needs mentioning that the =’ sign is used for tagging arguments in function calls and for assigning default values in function definitions.\nThe $’ sign is in some sense an operator, but does not allow arbitrary right hand sides and is discussed under Index constructions. It has higher precedence than any of the other operators.\nThe parsed form of a unary or binary operation is completely equivalent to a function call with the operator as the function name and the operands as the function arguments.\nParentheses are recorded as equivalent to a unary operator, with name \"(\", even in cases where the parentheses could be inferred from operator precedence (e.g., a * (b + c)).\nNotice that the  assignment symbols are operators just like the arithmetic, relational, and logical ones. Any expression is allowed also on the target side of an assignment, as far as the parser is concerned (2 + 2 &lt;- 5 is a valid expression as far as the parser is concerned. The evaluator will object, though). Similar comments apply to the model formula operator.\n\n\n10.4.3 Index constructions ¶\nR has three indexing constructs, two of which are syntactically similar although with somewhat different semantics:\nobject [ arg1, ...... , argn ]\nobject [[ arg1, ...... , argn ]]\n \nThe object can formally be any valid expression, but it is understood to denote or evaluate to a subsettable object. The arguments generally evaluate to numerical or character indices, but other kinds of arguments are possible (notably drop = FALSE).\nInternally, these index constructs are stored as function calls with function name \"[\" respectively \"[[\".\nThe third index construction is\nobject $ tag\nHere, object is as above, whereas tag is an identifier or a text string. Internally, it is stored as a function call with name \"$\"\n\n\n10.4.4 Compound expressions ¶\nA compound expression is of the form\n{ expr1 ; expr2 ; ...... ; exprn }\nThe semicolons may be replaced by newlines. Internally, this is stored as a function call with \"{\" as the function name and the expressions as arguments.\n\n\n10.4.5 Flow control elements ¶\nR contains the following control structures as special syntactic constructs\nif ( cond ) expr\nif ( cond ) expr1 else expr2\nwhile ( cond ) expr\nrepeat expr\nfor ( var in list ) expr\nThe expressions in these constructs will typically be compound expressions.\nWithin the loop constructs (while, repeat, for), one may use break (to terminate the loop) and next (to skip to the next iteration).\nInternally, the constructs are stored as function calls:\n\"if\"(cond, expr)\n\"if\"(cond, expr1, expr2)\n\"while\"(cond, expr)\n\"repeat\"(expr)\n\"for\"(var, list, expr)\n\"break\"()\n\"next\"()\n\n\n10.4.6 Function definitions ¶\nA  function definition is of the form\nfunction ( arglist ) body\nThe function body is an expression, often a compound expression. The arglist is a comma-separated list of items each of which can be an identifier, or of the form identifier=default’, or the special token .... The default can be any valid expression.\nNotice that function arguments unlike list tags, etc., cannot have “strange names” given as text strings.\nInternally, a function definition is stored as a function call with function name function and two arguments, the arglist and the body. The arglist is stored as a tagged pairlist where the tags are the argument names and the values are the default expressions.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Parser.html#directives",
    "href": "Parser.html#directives",
    "title": "10  Parser ¶",
    "section": "10.5 Directives ¶",
    "text": "10.5 Directives ¶\nThe parser currently only supports one directive, #line. This is similar to the C-preprocessor directive of the same name. The syntax is\n#line nn [ \"filename\" ]\nwhere nn is an integer line number, and the optional filename (in required double quotes) names the source file.\nUnlike the C directive, #line must appear as the first five characters on a line. As in C, nn and \"filename\" entries may be separated from it by whitespace. And unlike C, any following text on the line will be treated as a comment and ignored.\nThis directive tells the parser that the following line should be assumed to be line nn of file filename. (If the filename is not given, it is assumed to be the same as for the previous directive.) This is not typically used by users, but may be used by preprocessors so that diagnostic messages refer to the original file.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Parser [¶](#parser-1){.copiable-link}</span>"
    ]
  },
  {
    "objectID": "Function-and-Variable-Index.html",
    "href": "Function-and-Variable-Index.html",
    "title": "Function and Variable Index ¶",
    "section": "",
    "text": "Next: Concept Index, Previous: Parser, Up: R Language Definition   [Contents][Index]\n\n\n\nJump to:  \n.   [   #   $  \nA   B   D   E   F   G   I   M   N   O   P   Q   R   S   T   U   W  \n\n\n\n\n\n\n\nIndex Entry\nSection\n\n\n.\n\n\n\n\n\n.C\nForeign language interfaces\n\n\n\n.Call\nForeign language interfaces\n\n\n\n.External\nForeign language interfaces\n\n\n\n.Fortran\nForeign language interfaces\n\n\n\n.Internal\n.Internal and .Primitive\n\n\n\n.Primitive\n.Internal and .Primitive\n\n\n[\n\n\n\n\n\n[\nIndexing\n\n\n\n[\nIndex constructions\n\n\n\n[[\nIndexing\n\n\n\n[[\nIndex constructions\n\n\n#\n\n\n\n\n\n#\nComments\n\n\n$\n\n\n\n\n\n$\nIndexing\n\n\n\n$\nIndex constructions\n\n\nA\n\n\n\n\n\nas.call\nLanguage objects\n\n\n\nas.character\nSymbol objects\n\n\n\nas.function\nFunction objects\n\n\n\nas.list\nLanguage objects\n\n\n\nas.name\nSymbol objects\n\n\n\nassign\nEnvironment objects\n\n\n\nassign\nIdentifiers\n\n\n\nattr\nAttributes\n\n\n\nattr&lt;-\nAttributes\n\n\n\nattributes\nAttributes\n\n\n\nattributes&lt;-\nAttributes\n\n\nB\n\n\n\n\n\nbaseenv\nEnvironment objects\n\n\n\nbasename\nOperating system access\n\n\n\nbody\nFunction objects\n\n\n\nbody\nManipulation of functions\n\n\n\nbody&lt;-\nManipulation of functions\n\n\n\nbreak\nLooping\n\n\n\nbrowser\nbrowser\n\n\nD\n\n\n\n\n\ndebug\ndebug/undebug\n\n\n\ndirname\nOperating system access\n\n\n\ndo.call\nManipulation of function calls\n\n\nE\n\n\n\n\n\nemptyenv\nEnvironment objects\n\n\n\nenvironment\nFunction objects\n\n\n\nenvironment\nManipulation of functions\n\n\n\nenvironment&lt;-\nManipulation of functions\n\n\n\neval\nMore on evaluation\n\n\nF\n\n\n\n\n\nfile.access\nOperating system access\n\n\n\nfile.append\nOperating system access\n\n\n\nfile.choose\nOperating system access\n\n\n\nfile.copy\nOperating system access\n\n\n\nfile.create\nOperating system access\n\n\n\nfile.exists\nOperating system access\n\n\n\nfile.info\nOperating system access\n\n\n\nfile.path\nOperating system access\n\n\n\nfile.remove\nOperating system access\n\n\n\nfile.rename\nOperating system access\n\n\n\nfile.show\nOperating system access\n\n\n\nfor\nfor\n\n\n\nformals\nFunction objects\n\n\n\nformals\nManipulation of functions\n\n\n\nformals&lt;-\nManipulation of functions\n\n\nG\n\n\n\n\n\nget\nEnvironment objects\n\n\n\nget\nIdentifiers\n\n\n\nget0\nEnvironment objects\n\n\nI\n\n\n\n\n\nis.na\nNA handling\n\n\n\nis.nan\nNA handling\n\n\nM\n\n\n\n\n\nmatch.arg\nArgument matching\n\n\n\nmatch.call\nArgument matching\n\n\n\nmatch.call\nManipulation of function calls\n\n\n\nmatch.fun\nArgument matching\n\n\n\nmissing\nNA handling\n\n\n\nmode\nObjects\n\n\nN\n\n\n\n\n\nNA\nNA handling\n\n\n\nNA\nIndexing by vectors\n\n\n\nnames\nNames\n\n\n\nnames&lt;-\nNames\n\n\n\nNaN\nNA handling\n\n\n\nnew.env\nEnvironment objects\n\n\n\nnext\nLooping\n\n\n\nNextMethod\nNextMethod\n\n\n\nNULL\nNULL object\n\n\nO\n\n\n\n\n\non.exit\non.exit\n\n\nP\n\n\n\n\n\npairlist\nPairlist objects\n\n\n\npath.expand\nOperating system access\n\n\n\nproc.time\nOperating system access\n\n\nQ\n\n\n\n\n\nquote\nLanguage objects\n\n\nR\n\n\n\n\n\nrepeat\nrepeat\n\n\nS\n\n\n\n\n\nstop\nstop\n\n\n\nstorage.mode\nObjects\n\n\n\nsubstitute\nSubstitutions\n\n\n\nswitch\nswitch\n\n\n\nSys.getenv\nOperating system access\n\n\n\nSys.getlocale\nOperating system access\n\n\n\nSys.localeconv\nOperating system access\n\n\n\nSys.putenv\nOperating system access\n\n\n\nSys.putlocale\nOperating system access\n\n\n\nSys.time\nOperating system access\n\n\n\nSys.timezone\nOperating system access\n\n\n\nsystem\nOperating system access\n\n\n\nsystem.time\nOperating system access\n\n\nT\n\n\n\n\n\ntrace\ntrace/untrace\n\n\n\ntraceback\ntraceback\n\n\n\ntypeof\nObjects\n\n\nU\n\n\n\n\n\nundebug\ndebug/undebug\n\n\n\nunlink\nOperating system access\n\n\n\nuntrace\ntrace/untrace\n\n\n\nUseMethod\nUseMethod\n\n\nW\n\n\n\n\n\nwarning\nwarning\n\n\n\nwarnings\nwarning\n\n\n\nwhile\nwhile\n\n\n\n\n\n\nJump to:  \n.   [   #   $  \nA   B   D   E   F   G   I   M   N   O   P   Q   R   S   T   U   W  \n\n\n\nNext: Concept Index, Previous: Parser, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "Function and Variable Index [¶](#function-and-variable-index-1){.copiable-link}"
    ]
  },
  {
    "objectID": "Concept-Index.html",
    "href": "Concept-Index.html",
    "title": "Concept Index ¶",
    "section": "",
    "text": "Next: References, Previous: Function and Variable Index, Up: R Language Definition   [Contents][Index]\n\n\n\nJump to:  \n.   #  \nA   B   C   E   F   I   M   N   O   P   S   T   V  \n\n\n\n\n\n\n\nIndex Entry\nSection\n\n\n.\n\n\n\n\n\n.Internal\nBuiltin objects and special forms\n\n\n\n.Primitive\nBuiltin objects and special forms\n\n\n#\n\n\n\n\n\n#line\nDirectives\n\n\nA\n\n\n\n\n\nargument\nFunction objects\n\n\n\nargument\nSyntax and examples\n\n\n\nargument, default values\nArguments\n\n\n\nassignment\nFunction objects\n\n\n\nassignment\nFunction calls\n\n\n\nassignment\nOperators\n\n\n\nassignment\nSubset assignment\n\n\n\nassignment\nGlobal environment\n\n\n\nassignment\nArgument evaluation\n\n\n\nassignment\nScope\n\n\n\nassignment\nUseMethod\n\n\n\nassignment\nUseMethod\n\n\n\nassignment\nMore on evaluation\n\n\n\nassignment\nManipulation of function calls\n\n\n\nassignment\nInfix and prefix operators\n\n\n\nassignment\nInfix and prefix operators\n\n\n\natomic\nVector objects\n\n\n\nattributes\nAttributes\n\n\nB\n\n\n\n\n\nbinding\nScope\n\n\n\nbinding\nScope\n\n\nC\n\n\n\n\n\ncall\nLanguage objects\n\n\n\ncall stack\nStacks\n\n\n\ncoercion\nObjects\n\n\n\ncoercion\nSymbol objects\n\n\n\ncoercion\nAny-type\n\n\n\ncoercion\nClasses\n\n\n\ncoercion\nNA handling\n\n\n\ncomments\nComments\n\n\n\ncomplex assignment\nSubset assignment\n\n\nE\n\n\n\n\n\nenvironment\nFunction objects\n\n\n\nenvironment\nFunction objects\n\n\n\nenvironment\nPromise objects\n\n\n\nenvironment\nEnvironment objects\n\n\n\nenvironment\nControl structures\n\n\n\nenvironment\nGlobal environment\n\n\n\nenvironment\nLexical environment\n\n\n\nenvironment\nStacks\n\n\n\nenvironment\nSearch path\n\n\n\nenvironment\nEvaluation environment\n\n\n\nenvironment\nArgument evaluation\n\n\n\nenvironment\nArgument evaluation\n\n\n\nenvironment\nScope\n\n\n\nenvironment\nUseMethod\n\n\n\nenvironment\nUseMethod\n\n\n\nenvironment\nMore on evaluation\n\n\n\nenvironment\nManipulation of functions\n\n\n\nenvironment\nOperating system access\n\n\n\nenvironment\nDebugging\n\n\n\nenvironment\nDebugging\n\n\n\nenvironment, evaluation\nLexical environment\n\n\n\nenvironment, evaluation\nLexical environment\n\n\n\nenvironment, evaluation\nArgument evaluation\n\n\n\nevaluation\nStacks\n\n\n\nevaluation\nEvaluation environment\n\n\n\nevaluation\nArgument evaluation\n\n\n\nevaluation\nScope\n\n\n\nevaluation\nInheritance\n\n\n\nevaluation\nUseMethod\n\n\n\nevaluation\nMore on evaluation\n\n\n\nevaluation\nManipulation of function calls\n\n\n\nevaluation, argument\nArgument evaluation\n\n\n\nevaluation, expression\nExpression objects\n\n\n\nevaluation, expression\nPromise objects\n\n\n\nevaluation, expression\nArguments\n\n\n\nevaluation, lazy\nObjects\n\n\n\nevaluation, lazy\nSubstitutions\n\n\n\nevaluation, lazy\nSubstitutions\n\n\n\nevaluation, statement\nControl structures\n\n\n\nevaluation, symbol\nAttributes\n\n\n\nevaluation, symbol\nSymbol lookup\n\n\n\nevaluation, symbol\nScope\n\n\n\nexpression\nIntroduction\n\n\n\nexpression\nLanguage objects\n\n\n\nexpression\nSeparators\n\n\n\nexpression object\nExpression objects\n\n\n\nexpression object\nExpression objects\n\n\nF\n\n\n\n\n\nframe\nLexical environment\n\n\n\nfunction\nFunction objects\n\n\n\nfunction\nFunction objects\n\n\n\nfunction\nFunction objects\n\n\n\nfunction\nBuiltin objects and special forms\n\n\n\nfunction\nBuiltin objects and special forms\n\n\n\nfunction\nPromise objects\n\n\n\nfunction\nDot-dot-dot\n\n\n\nfunction\nFunction calls\n\n\n\nfunction\nLexical environment\n\n\n\nfunction\nLexical environment\n\n\n\nfunction\nStacks\n\n\n\nfunction\nWriting functions\n\n\n\nfunction\nSyntax and examples\n\n\n\nfunction\nSyntax and examples\n\n\n\nfunction\nArguments\n\n\n\nfunction\nEvaluation environment\n\n\n\nfunction\nArgument matching\n\n\n\nfunction\nArgument evaluation\n\n\n\nfunction\nArgument evaluation\n\n\n\nfunction\nArgument evaluation\n\n\n\nfunction\nArgument evaluation\n\n\n\nfunction\nScope\n\n\n\nfunction\nScope\n\n\n\nfunction\nObject-oriented programming\n\n\n\nfunction\nDefinition\n\n\n\nfunction\nManipulation of function calls\n\n\n\nfunction\nManipulation of functions\n\n\n\nfunction\nManipulation of functions\n\n\n\nfunction\nInternal representation\n\n\n\nfunction\nFunction calls (expressions)\n\n\n\nfunction\nFunction definitions\n\n\n\nfunction argument\nPromise objects\n\n\n\nfunction argument\nDot-dot-dot\n\n\n\nfunction arguments\nFunction calls\n\n\n\nfunction invocation\nFunction calls\n\n\n\nfunction, accessor\nAttributes\n\n\n\nfunction, anonymous\nSyntax and examples\n\n\n\nfunction, assignment\nFunction calls\n\n\n\nfunction, generic\nObject-oriented programming\n\n\n\nfunction, generic\nDefinition\n\n\n\nfunction, generic\nDefinition\n\n\n\nfunction, generic\nDefinition\n\n\n\nfunction, generic\nInheritance\n\n\n\nfunction, generic\nMethod dispatching\n\n\n\nfunction, generic\nWriting methods\n\n\n\nfunction, generic\nWriting methods\n\n\n\nfunction, internal\nArgument evaluation\n\n\n\nfunction, internal\nGroup methods\n\n\n\nfunction, modeling\nFactors\n\n\nI\n\n\n\n\n\nidentifier\nIdentifiers\n\n\n\nindex\nVector objects\n\n\n\nindex\nList objects\n\n\n\nindex\nIndexing\n\n\n\nindex\nIndexing by vectors\n\n\n\nindex\nIndexing matrices and arrays\n\n\n\nindex\nIndexing matrices and arrays\n\n\nM\n\n\n\n\n\nmode\nObjects\n\n\n\nmode\nVector objects\n\n\n\nmode\nSymbol objects\n\n\n\nmodeling function\nFactors\n\n\nN\n\n\n\n\n\nname\nLanguage objects\n\n\n\nname\nSymbol objects\n\n\n\nname\nSymbol lookup\n\n\n\nname\nPropagation of names\n\n\n\nname\nScope of variables\n\n\n\nname\nArguments\n\n\n\nname\nArgument matching\n\n\n\nname\nArgument evaluation\n\n\n\nname\nMethod dispatching\n\n\n\nname\nNextMethod\n\n\n\nname\nDirect manipulation of language objects\n\n\n\nname\nDebugging\n\n\n\nnamespace\nSearch path\n\n\nO\n\n\n\n\n\nobject\nObjects\n\n\n\nobject\nObjects\n\n\n\nobject\nSymbol objects\n\n\n\nobject\nAttributes\n\n\n\nobject\nMethod dispatching\n\n\n\nobject-oriented\nObject-oriented programming\n\n\n\nobject-oriented\nDefinition\n\n\nP\n\n\n\n\n\npairlist\nPairlist objects\n\n\n\nparsing\nLanguage objects\n\n\n\nparsing\nSymbol objects\n\n\n\nparsing\nEvaluation of expressions\n\n\n\nparsing\nComputing on the language\n\n\n\nparsing\nDirect manipulation of language objects\n\n\n\nparsing\nSubstitutions\n\n\n\nparsing\nParser\n\n\n\nparsing\nInternal representation\n\n\n\npartial matching\nIndexing by vectors\n\n\n\npromise\nPromise objects\n\n\nS\n\n\n\n\n\nscope\nScope of variables\n\n\n\nscope\nStacks\n\n\n\nscope\nScope\n\n\n\nscope\nScope\n\n\n\nscope\nScope\n\n\n\nscope\nMore on evaluation\n\n\n\nsearch path\nSearch path\n\n\n\nstatement\nLanguage objects\n\n\n\nsymbol\nSymbol objects\n\n\n\nsymbol\nSymbol objects\n\n\n\nsymbol\nSymbol lookup\n\n\n\nsymbol\nScope\n\n\n\nsymbol\nSubstitutions\n\n\n\nsymbol\nManipulation of function calls\n\n\nT\n\n\n\n\n\ntoken\nExpression objects\n\n\n\ntype\nObjects\n\n\n\ntype\nObjects\n\n\n\ntype\nBasic types\n\n\n\ntype\nVector objects\n\n\n\ntype\nNames\n\n\n\ntype\nNA handling\n\n\nV\n\n\n\n\n\nvalue\nSymbol lookup\n\n\n\nvariable\nObjects\n\n\n\nvector\nVector objects\n\n\n\nvector\nDimensions\n\n\n\nvector\nOperators\n\n\n\n\n\n\nJump to:  \n.   #  \nA   B   C   E   F   I   M   N   O   P   S   T   V  \n\n\n\nNext: References, Previous: Function and Variable Index, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "Concept Index [¶](#concept-index-1){.copiable-link}"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "Appendix A — References ¶",
    "section": "",
    "text": "Previous: Concept Index, Up: R Language Definition   [Contents][Index]\nRichard A. Becker, John M. Chambers and Allan R. Wilks (1988), The New S Language. Chapman & Hall, New York. This book is often called the “Blue Book”.\nPrevious: Concept Index, Up: R Language Definition   [Contents][Index]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>References [¶](#references-1){.copiable-link}</span>"
    ]
  }
]